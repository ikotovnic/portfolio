{"ast":null,"code":"var _defineProperty2 = require(\"/Users/mac-ikotov/Sites/vue/test3/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _toConsumableArray = require(\"/Users/mac-ikotov/Sites/vue/test3/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _objectSpread = require(\"/Users/mac-ikotov/Sites/vue/test3/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/Users/mac-ikotov/Sites/vue/test3/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _inherits = require(\"/Users/mac-ikotov/Sites/vue/test3/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/Users/mac-ikotov/Sites/vue/test3/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _asyncToGenerator = require(\"/Users/mac-ikotov/Sites/vue/test3/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"/Users/mac-ikotov/Sites/vue/test3/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/mac-ikotov/Sites/vue/test3/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _typeof = require(\"/Users/mac-ikotov/Sites/vue/test3/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nrequire(\"core-js/modules/es.global-this.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.object.keys.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.symbol.to-string-tag.js\");\n\nrequire(\"core-js/modules/es.json.to-string-tag.js\");\n\nrequire(\"core-js/modules/es.math.to-string-tag.js\");\n\nrequire(\"core-js/modules/es.symbol.iterator.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.array.from.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.array.filter.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptors.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.json.stringify.js\");\n\nrequire(\"core-js/modules/es.array.splice.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.constructor.js\");\n\nrequire(\"core-js/modules/es.regexp.dot-all.js\");\n\nrequire(\"core-js/modules/es.regexp.sticky.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nrequire(\"core-js/modules/es.object.get-prototype-of.js\");\n\nrequire(\"core-js/modules/es.string.split.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nrequire(\"core-js/modules/es.number.constructor.js\");\n\nrequire(\"core-js/modules/es.string.match.js\");\n\nrequire(\"core-js/modules/es.string.repeat.js\");\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.array.find.js\");\n\n(function (global, factory) {\n  (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Handsfree = factory());\n})(this, function () {\n  'use strict';\n\n  var _pluginPinchers, _pluginPalmPointers;\n\n  var BaseModel = /*#__PURE__*/function () {\n    function BaseModel(handsfree, config) {\n      var _arguments = arguments,\n          _this = this;\n\n      _classCallCheck(this, BaseModel);\n\n      this.handsfree = handsfree;\n      this.config = config;\n      this.data = {}; // Whether we've loaded dependencies or not\n\n      this.dependenciesLoaded = false; // Whether the model is enabled or not\n\n      this.enabled = config.enabled; // Collection of plugins and gestures\n\n      this.plugins = [];\n      this.gestures = [];\n      this.gestureEstimator = null;\n      setTimeout(function () {\n        // Get data\n        var getData = _this.getData;\n        _this.getData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n          var data;\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return getData.apply(_this, _arguments);\n\n                case 2:\n                  _context.t0 = _context.sent;\n\n                  if (_context.t0) {\n                    _context.next = 5;\n                    break;\n                  }\n\n                  _context.t0 = {};\n\n                case 5:\n                  data = _context.t0;\n                  data.gesture = _this.getGesture();\n\n                  _this.runPlugins();\n\n                  return _context.abrupt(\"return\", data);\n\n                case 9:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        })); // Get gesture\n\n        var getGesture = _this.getGesture;\n\n        _this.getGesture = function () {\n          if (!getGesture) {\n            getGesture = function getGesture() {};\n          }\n\n          return getGesture.apply(_this, _arguments);\n        };\n      }, 0);\n    } // Implement in the model class\n\n\n    _createClass(BaseModel, [{\n      key: \"loadDependencies\",\n      value: function loadDependencies() {}\n    }, {\n      key: \"updateData\",\n      value: function updateData() {}\n    }, {\n      key: \"updateGestureEstimator\",\n      value: function updateGestureEstimator() {}\n      /**\r\n       * Enable model\r\n       * @param {*} handleLoad If true then it'll also attempt to load,\r\n       *    otherwise you'll need to handle it yourself. This is mostly used internally\r\n       *    to prevent the .update() method from double loading\r\n       */\n\n    }, {\n      key: \"enable\",\n      value: function enable() {\n        var handleLoad = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.handsfree.config[this.name] = this.config;\n        this.handsfree.config[this.name].enabled = this.enabled = true;\n        document.body.classList.add(\"handsfree-model-\".concat(this.name));\n\n        if (handleLoad && !this.dependenciesLoaded) {\n          this.loadDependencies();\n        } // Weboji uses a webgl context\n\n\n        if (this.name === 'weboji') {\n          this.handsfree.debug.$canvas.weboji.style.display = 'block';\n        }\n      }\n    }, {\n      key: \"disable\",\n      value: function disable() {\n        var _this2 = this;\n\n        this.handsfree.config[this.name] = this.config;\n        this.handsfree.config[this.name].enabled = this.enabled = false;\n        document.body.classList.remove(\"handsfree-model-\".concat(this.name));\n        setTimeout(function () {\n          // Weboji uses a webgl context so let's just hide it\n          if (_this2.name === 'weboji') {\n            _this2.handsfree.debug.$canvas.weboji.style.display = 'none';\n          } else {\n            var _this$handsfree$debug;\n\n            ((_this$handsfree$debug = _this2.handsfree.debug.context[_this2.name]) === null || _this$handsfree$debug === void 0 ? void 0 : _this$handsfree$debug.clearRect) && _this2.handsfree.debug.context[_this2.name].clearRect(0, 0, _this2.handsfree.debug.$canvas[_this2.name].width, _this2.handsfree.debug.$canvas[_this2.name].height);\n          } // Stop if all models have been stopped\n\n\n          var hasRunningModels = Object.keys(_this2.handsfree.model).some(function (model) {\n            return _this2.handsfree.model[model].enabled;\n          });\n\n          if (!hasRunningModels) {\n            _this2.handsfree.stop();\n          }\n        }, 0);\n      }\n      /**\r\n       * Loads a script and runs a callback\r\n       * @param {string} src The absolute path of the source file\r\n       * @param {*} callback The callback to call after the file is loaded\r\n       * @param {boolean} skip Whether to skip loading the dependency and just call the callback\r\n       */\n\n    }, {\n      key: \"loadDependency\",\n      value: function loadDependency(src, callback) {\n        var _this3 = this;\n\n        var skip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        // Skip and run callback\n        if (skip) {\n          callback && callback();\n          return;\n        } // Inject script into DOM\n\n\n        var $script = document.createElement('script');\n        $script.async = true;\n\n        $script.onload = function () {\n          callback && callback();\n        };\n\n        $script.onerror = function () {\n          _this3.handsfree.emit('modelError', \"Error loading \".concat(src));\n        };\n\n        $script.src = src;\n        document.body.appendChild($script);\n      }\n      /**\r\n       * Run all the plugins attached to this model\r\n       */\n\n    }, {\n      key: \"runPlugins\",\n      value: function runPlugins() {\n        var _this4 = this;\n\n        // Exit if no data\n        if (!this.data || this.name === 'handpose' && !this.data.annotations) {\n          return;\n        }\n\n        if (Object.keys(this.data).length) {\n          this.plugins.forEach(function (name) {\n            var _this$handsfree$plugi;\n\n            _this4.handsfree.plugin[name].enabled && ((_this$handsfree$plugi = _this4.handsfree.plugin[name]) === null || _this$handsfree$plugi === void 0 ? void 0 : _this$handsfree$plugi.onFrame(_this4.handsfree.data));\n          });\n        }\n      }\n    }]);\n\n    return BaseModel;\n  }();\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n  }\n\n  function createCommonjsModule(fn, basedir, module) {\n    return module = {\n      path: basedir,\n      exports: {},\n      require: function require(path, base) {\n        return commonjsRequire(path, base === undefined || base === null ? module.path : base);\n      }\n    }, fn(module, module.exports), module.exports;\n  }\n\n  function commonjsRequire() {\n    throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n  }\n\n  var fingerpose = createCommonjsModule(function (module, exports) {\n    !function (t, e) {\n      module.exports = e();\n    }(\"undefined\" != typeof self ? self : commonjsGlobal, function () {\n      return function (t) {\n        var e = {};\n\n        function n(r) {\n          if (e[r]) return e[r].exports;\n          var i = e[r] = {\n            i: r,\n            l: !1,\n            exports: {}\n          };\n          return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports;\n        }\n\n        return n.m = t, n.c = e, n.d = function (t, e, r) {\n          n.o(t, e) || Object.defineProperty(t, e, {\n            enumerable: !0,\n            get: r\n          });\n        }, n.r = function (t) {\n          \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n            value: \"Module\"\n          }), Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          });\n        }, n.t = function (t, e) {\n          if (1 & e && (t = n(t)), 8 & e) return t;\n          if (4 & e && \"object\" == _typeof(t) && t && t.__esModule) return t;\n          var r = Object.create(null);\n          if (n.r(r), Object.defineProperty(r, \"default\", {\n            enumerable: !0,\n            value: t\n          }), 2 & e && \"string\" != typeof t) for (var i in t) {\n            n.d(r, i, function (e) {\n              return t[e];\n            }.bind(null, i));\n          }\n          return r;\n        }, n.n = function (t) {\n          var e = t && t.__esModule ? function () {\n            return t.default;\n          } : function () {\n            return t;\n          };\n          return n.d(e, \"a\", e), e;\n        }, n.o = function (t, e) {\n          return Object.prototype.hasOwnProperty.call(t, e);\n        }, n.p = \"\", n(n.s = 0);\n      }([function (t, e, n) {\n        n.r(e);\n        var r = {};\n\n        function i(t) {\n          return (i = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (t) {\n            return _typeof(t);\n          } : function (t) {\n            return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : _typeof(t);\n          })(t);\n        }\n\n        n.r(r), n.d(r, \"VictoryGesture\", function () {\n          return C;\n        }), n.d(r, \"ThumbsUpGesture\", function () {\n          return j;\n        });\n        var o = {\n          Thumb: 0,\n          Index: 1,\n          Middle: 2,\n          Ring: 3,\n          Pinky: 4,\n          all: [0, 1, 2, 3, 4],\n          nameMapping: {\n            0: \"Thumb\",\n            1: \"Index\",\n            2: \"Middle\",\n            3: \"Ring\",\n            4: \"Pinky\"\n          },\n          pointsMapping: {\n            0: [[0, 1], [1, 2], [2, 3], [3, 4]],\n            1: [[0, 5], [5, 6], [6, 7], [7, 8]],\n            2: [[0, 9], [9, 10], [10, 11], [11, 12]],\n            3: [[0, 13], [13, 14], [14, 15], [15, 16]],\n            4: [[0, 17], [17, 18], [18, 19], [19, 20]]\n          },\n          getName: function getName(t) {\n            return void 0 !== i(this.nameMapping[t]) && this.nameMapping[t];\n          },\n          getPoints: function getPoints(t) {\n            return void 0 !== i(this.pointsMapping[t]) && this.pointsMapping[t];\n          }\n        },\n            a = {\n          NoCurl: 0,\n          HalfCurl: 1,\n          FullCurl: 2,\n          nameMapping: {\n            0: \"No Curl\",\n            1: \"Half Curl\",\n            2: \"Full Curl\"\n          },\n          getName: function getName(t) {\n            return void 0 !== i(this.nameMapping[t]) && this.nameMapping[t];\n          }\n        },\n            l = {\n          VerticalUp: 0,\n          VerticalDown: 1,\n          HorizontalLeft: 2,\n          HorizontalRight: 3,\n          DiagonalUpRight: 4,\n          DiagonalUpLeft: 5,\n          DiagonalDownRight: 6,\n          DiagonalDownLeft: 7,\n          nameMapping: {\n            0: \"Vertical Up\",\n            1: \"Vertical Down\",\n            2: \"Horizontal Left\",\n            3: \"Horizontal Right\",\n            4: \"Diagonal Up Right\",\n            5: \"Diagonal Up Left\",\n            6: \"Diagonal Down Right\",\n            7: \"Diagonal Down Left\"\n          },\n          getName: function getName(t) {\n            return void 0 !== i(this.nameMapping[t]) && this.nameMapping[t];\n          }\n        };\n\n        function u(t) {\n          if (\"undefined\" == typeof Symbol || null == t[Symbol.iterator]) {\n            if (Array.isArray(t) || (t = function (t, e) {\n              if (!t) return;\n              if (\"string\" == typeof t) return c(t, e);\n              var n = Object.prototype.toString.call(t).slice(8, -1);\n              \"Object\" === n && t.constructor && (n = t.constructor.name);\n              if (\"Map\" === n || \"Set\" === n) return Array.from(n);\n              if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return c(t, e);\n            }(t))) {\n              var e = 0,\n                  n = function n() {};\n\n              return {\n                s: n,\n                n: function n() {\n                  return e >= t.length ? {\n                    done: !0\n                  } : {\n                    done: !1,\n                    value: t[e++]\n                  };\n                },\n                e: function e(t) {\n                  throw t;\n                },\n                f: n\n              };\n            }\n\n            throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n          }\n\n          var r,\n              i,\n              o = !0,\n              a = !1;\n          return {\n            s: function s() {\n              r = t[Symbol.iterator]();\n            },\n            n: function n() {\n              var t = r.next();\n              return o = t.done, t;\n            },\n            e: function e(t) {\n              a = !0, i = t;\n            },\n            f: function f() {\n              try {\n                o || null == r.return || r.return();\n              } finally {\n                if (a) throw i;\n              }\n            }\n          };\n        }\n\n        function c(t, e) {\n          (null == e || e > t.length) && (e = t.length);\n\n          for (var n = 0, r = new Array(e); n < e; n++) {\n            r[n] = t[n];\n          }\n\n          return r;\n        }\n\n        function f(t, e) {\n          var n = Object.keys(t);\n\n          if (Object.getOwnPropertySymbols) {\n            var r = Object.getOwnPropertySymbols(t);\n            e && (r = r.filter(function (e) {\n              return Object.getOwnPropertyDescriptor(t, e).enumerable;\n            })), n.push.apply(n, r);\n          }\n\n          return n;\n        }\n\n        function s(t, e, n) {\n          return e in t ? Object.defineProperty(t, e, {\n            value: n,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n          }) : t[e] = n, t;\n        }\n\n        function h(t, e) {\n          for (var n = 0; n < e.length; n++) {\n            var r = e[n];\n            r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n          }\n        }\n\n        var d = function () {\n          function t(e) {\n            !function (t, e) {\n              if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n            }(this, t), this.options = function (t) {\n              for (var e = 1; e < arguments.length; e++) {\n                var n = null != arguments[e] ? arguments[e] : {};\n                e % 2 ? f(Object(n), !0).forEach(function (e) {\n                  s(t, e, n[e]);\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : f(Object(n)).forEach(function (e) {\n                  Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e));\n                });\n              }\n\n              return t;\n            }({}, {\n              HALF_CURL_START_LIMIT: 60,\n              NO_CURL_START_LIMIT: 130,\n              DISTANCE_VOTE_POWER: 1.1,\n              SINGLE_ANGLE_VOTE_POWER: .9,\n              TOTAL_ANGLE_VOTE_POWER: 1.6\n            }, {}, e);\n          }\n\n          var e, n;\n          return e = t, (n = [{\n            key: \"estimate\",\n            value: function value(t) {\n              var e,\n                  n = [],\n                  r = [],\n                  i = u(o.all);\n\n              try {\n                for (i.s(); !(e = i.n()).done;) {\n                  var a,\n                      l = e.value,\n                      c = o.getPoints(l),\n                      f = [],\n                      s = [],\n                      h = u(c);\n\n                  try {\n                    for (h.s(); !(a = h.n()).done;) {\n                      var d = a.value,\n                          p = t[d[0]],\n                          y = t[d[1]],\n                          g = this.getSlopes(p, y),\n                          v = g[0],\n                          m = g[1];\n                      f.push(v), s.push(m);\n                    }\n                  } catch (t) {\n                    h.e(t);\n                  } finally {\n                    h.f();\n                  }\n\n                  n.push(f), r.push(s);\n                }\n              } catch (t) {\n                i.e(t);\n              } finally {\n                i.f();\n              }\n\n              var b,\n                  D = [],\n                  w = [],\n                  O = u(o.all);\n\n              try {\n                for (O.s(); !(b = O.n()).done;) {\n                  var M = b.value,\n                      S = M == o.Thumb ? 1 : 0,\n                      T = o.getPoints(M),\n                      C = t[T[S][0]],\n                      R = t[T[S + 1][1]],\n                      A = t[T[3][1]],\n                      L = this.estimateFingerCurl(C, R, A),\n                      _ = this.calculateFingerDirection(C, R, A, n[M].slice(S));\n\n                  D[M] = L, w[M] = _;\n                }\n              } catch (t) {\n                O.e(t);\n              } finally {\n                O.f();\n              }\n\n              return {\n                curls: D,\n                directions: w\n              };\n            }\n          }, {\n            key: \"getSlopes\",\n            value: function value(t, e) {\n              var n = this.calculateSlope(t[0], t[1], e[0], e[1]);\n              return 2 == t.length ? n : [n, this.calculateSlope(t[1], t[2], e[1], e[2])];\n            }\n          }, {\n            key: \"angleOrientationAt\",\n            value: function value(t) {\n              var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,\n                  n = 0,\n                  r = 0,\n                  i = 0;\n              return t >= 75 && t <= 105 ? n = 1 * e : t >= 25 && t <= 155 ? r = 1 * e : i = 1 * e, [n, r, i];\n            }\n          }, {\n            key: \"estimateFingerCurl\",\n            value: function value(t, e, n) {\n              var r = t[0] - e[0],\n                  i = t[0] - n[0],\n                  o = e[0] - n[0],\n                  l = t[1] - e[1],\n                  u = t[1] - n[1],\n                  c = e[1] - n[1],\n                  f = t[2] - e[2],\n                  s = t[2] - n[2],\n                  h = e[2] - n[2],\n                  d = Math.sqrt(r * r + l * l + f * f),\n                  p = Math.sqrt(i * i + u * u + s * s),\n                  y = Math.sqrt(o * o + c * c + h * h),\n                  g = (y * y + d * d - p * p) / (2 * y * d);\n              g > 1 ? g = 1 : g < -1 && (g = -1);\n              var v = Math.acos(g);\n              return (v = 57.2958 * v % 180) > this.options.NO_CURL_START_LIMIT ? a.NoCurl : v > this.options.HALF_CURL_START_LIMIT ? a.HalfCurl : a.FullCurl;\n            }\n          }, {\n            key: \"estimateHorizontalDirection\",\n            value: function value(t, e, n, r) {\n              return r == Math.abs(t) ? t > 0 ? l.HorizontalLeft : l.HorizontalRight : r == Math.abs(e) ? e > 0 ? l.HorizontalLeft : l.HorizontalRight : n > 0 ? l.HorizontalLeft : l.HorizontalRight;\n            }\n          }, {\n            key: \"estimateVerticalDirection\",\n            value: function value(t, e, n, r) {\n              return r == Math.abs(t) ? t < 0 ? l.VerticalDown : l.VerticalUp : r == Math.abs(e) ? e < 0 ? l.VerticalDown : l.VerticalUp : n < 0 ? l.VerticalDown : l.VerticalUp;\n            }\n          }, {\n            key: \"estimateDiagonalDirection\",\n            value: function value(t, e, n, r, i, o, a, u) {\n              var c = this.estimateVerticalDirection(t, e, n, r),\n                  f = this.estimateHorizontalDirection(i, o, a, u);\n              return c == l.VerticalUp ? f == l.HorizontalLeft ? l.DiagonalUpLeft : l.DiagonalUpRight : f == l.HorizontalLeft ? l.DiagonalDownLeft : l.DiagonalDownRight;\n            }\n          }, {\n            key: \"calculateFingerDirection\",\n            value: function value(t, e, n, r) {\n              var i = t[0] - e[0],\n                  o = t[0] - n[0],\n                  a = e[0] - n[0],\n                  l = t[1] - e[1],\n                  c = t[1] - n[1],\n                  f = e[1] - n[1],\n                  s = Math.max(Math.abs(i), Math.abs(o), Math.abs(a)),\n                  h = Math.max(Math.abs(l), Math.abs(c), Math.abs(f)),\n                  d = 0,\n                  p = 0,\n                  y = 0,\n                  g = h / (s + 1e-5);\n              g > 1.5 ? d += this.options.DISTANCE_VOTE_POWER : g > .66 ? p += this.options.DISTANCE_VOTE_POWER : y += this.options.DISTANCE_VOTE_POWER;\n              var v = Math.sqrt(i * i + l * l),\n                  m = Math.sqrt(o * o + c * c),\n                  b = Math.sqrt(a * a + f * f),\n                  D = Math.max(v, m, b),\n                  w = t[0],\n                  O = t[1],\n                  M = n[0],\n                  S = n[1];\n              D == v ? (M = n[0], S = n[1]) : D == b && (w = e[0], O = e[1]);\n              var T = [w, O],\n                  C = [M, S],\n                  R = this.getSlopes(T, C),\n                  A = this.angleOrientationAt(R, this.options.TOTAL_ANGLE_VOTE_POWER);\n              d += A[0], p += A[1], y += A[2];\n\n              var L,\n                  _ = u(r);\n\n              try {\n                for (_.s(); !(L = _.n()).done;) {\n                  var j = L.value,\n                      E = this.angleOrientationAt(j, this.options.SINGLE_ANGLE_VOTE_POWER);\n                  d += E[0], p += E[1], y += E[2];\n                }\n              } catch (t) {\n                _.e(t);\n              } finally {\n                _.f();\n              }\n\n              return d == Math.max(d, p, y) ? this.estimateVerticalDirection(c, l, f, h) : y == Math.max(p, y) ? this.estimateHorizontalDirection(o, i, a, s) : this.estimateDiagonalDirection(c, l, f, h, o, i, a, s);\n            }\n          }, {\n            key: \"calculateSlope\",\n            value: function value(t, e, n, r) {\n              var i = (e - r) / (t - n),\n                  o = 180 * Math.atan(i) / Math.PI;\n              return o <= 0 ? o = -o : o > 0 && (o = 180 - o), o;\n            }\n          }]) && h(e.prototype, n), t;\n        }();\n\n        function p(t) {\n          if (\"undefined\" == typeof Symbol || null == t[Symbol.iterator]) {\n            if (Array.isArray(t) || (t = function (t, e) {\n              if (!t) return;\n              if (\"string\" == typeof t) return y(t, e);\n              var n = Object.prototype.toString.call(t).slice(8, -1);\n              \"Object\" === n && t.constructor && (n = t.constructor.name);\n              if (\"Map\" === n || \"Set\" === n) return Array.from(n);\n              if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return y(t, e);\n            }(t))) {\n              var e = 0,\n                  n = function n() {};\n\n              return {\n                s: n,\n                n: function n() {\n                  return e >= t.length ? {\n                    done: !0\n                  } : {\n                    done: !1,\n                    value: t[e++]\n                  };\n                },\n                e: function e(t) {\n                  throw t;\n                },\n                f: n\n              };\n            }\n\n            throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n          }\n\n          var r,\n              i,\n              o = !0,\n              a = !1;\n          return {\n            s: function s() {\n              r = t[Symbol.iterator]();\n            },\n            n: function n() {\n              var t = r.next();\n              return o = t.done, t;\n            },\n            e: function e(t) {\n              a = !0, i = t;\n            },\n            f: function f() {\n              try {\n                o || null == r.return || r.return();\n              } finally {\n                if (a) throw i;\n              }\n            }\n          };\n        }\n\n        function y(t, e) {\n          (null == e || e > t.length) && (e = t.length);\n\n          for (var n = 0, r = new Array(e); n < e; n++) {\n            r[n] = t[n];\n          }\n\n          return r;\n        }\n\n        function g(t, e) {\n          if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n        }\n\n        function v(t, e) {\n          for (var n = 0; n < e.length; n++) {\n            var r = e[n];\n            r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n          }\n        }\n\n        var m = function () {\n          function t(e) {\n            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n            g(this, t), this.estimator = new d(n), this.gestures = e;\n          }\n\n          var e, n;\n          return e = t, (n = [{\n            key: \"estimate\",\n            value: function value(t, e) {\n              var n,\n                  r = [],\n                  i = this.estimator.estimate(t),\n                  u = [],\n                  c = p(o.all);\n\n              try {\n                for (c.s(); !(n = c.n()).done;) {\n                  var f = n.value;\n                  u.push([o.getName(f), a.getName(i.curls[f]), l.getName(i.directions[f])]);\n                }\n              } catch (t) {\n                c.e(t);\n              } finally {\n                c.f();\n              }\n\n              var s,\n                  h = p(this.gestures);\n\n              try {\n                for (h.s(); !(s = h.n()).done;) {\n                  var d = s.value,\n                      y = d.matchAgainst(i.curls, i.directions);\n                  y >= e && r.push({\n                    name: d.name,\n                    confidence: y\n                  });\n                }\n              } catch (t) {\n                h.e(t);\n              } finally {\n                h.f();\n              }\n\n              return {\n                poseData: u,\n                gestures: r\n              };\n            }\n          }]) && v(e.prototype, n), t;\n        }();\n\n        function b(t, e) {\n          return function (t) {\n            if (Array.isArray(t)) return t;\n          }(t) || function (t, e) {\n            if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(t))) return;\n            var n = [],\n                r = !0,\n                i = !1,\n                o = void 0;\n\n            try {\n              for (var a, l = t[Symbol.iterator](); !(r = (a = l.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0) {\n                ;\n              }\n            } catch (t) {\n              i = !0, o = t;\n            } finally {\n              try {\n                r || null == l.return || l.return();\n              } finally {\n                if (i) throw o;\n              }\n            }\n\n            return n;\n          }(t, e) || w(t, e) || function () {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n          }();\n        }\n\n        function D(t) {\n          if (\"undefined\" == typeof Symbol || null == t[Symbol.iterator]) {\n            if (Array.isArray(t) || (t = w(t))) {\n              var e = 0,\n                  n = function n() {};\n\n              return {\n                s: n,\n                n: function n() {\n                  return e >= t.length ? {\n                    done: !0\n                  } : {\n                    done: !1,\n                    value: t[e++]\n                  };\n                },\n                e: function e(t) {\n                  throw t;\n                },\n                f: n\n              };\n            }\n\n            throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n          }\n\n          var r,\n              i,\n              o = !0,\n              a = !1;\n          return {\n            s: function s() {\n              r = t[Symbol.iterator]();\n            },\n            n: function n() {\n              var t = r.next();\n              return o = t.done, t;\n            },\n            e: function e(t) {\n              a = !0, i = t;\n            },\n            f: function f() {\n              try {\n                o || null == r.return || r.return();\n              } finally {\n                if (a) throw i;\n              }\n            }\n          };\n        }\n\n        function w(t, e) {\n          if (t) {\n            if (\"string\" == typeof t) return O(t, e);\n            var n = Object.prototype.toString.call(t).slice(8, -1);\n            return \"Object\" === n && t.constructor && (n = t.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(n) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? O(t, e) : void 0;\n          }\n        }\n\n        function O(t, e) {\n          (null == e || e > t.length) && (e = t.length);\n\n          for (var n = 0, r = new Array(e); n < e; n++) {\n            r[n] = t[n];\n          }\n\n          return r;\n        }\n\n        function M(t, e) {\n          for (var n = 0; n < e.length; n++) {\n            var r = e[n];\n            r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n          }\n        }\n\n        var S = function () {\n          function t(e) {\n            !function (t, e) {\n              if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n            }(this, t), this.name = e, this.curls = {}, this.directions = {}, this.weights = [1, 1, 1, 1, 1], this.weightsRelative = [1, 1, 1, 1, 1];\n          }\n\n          var e, n;\n          return e = t, (n = [{\n            key: \"addCurl\",\n            value: function value(t, e, n) {\n              void 0 === this.curls[t] && (this.curls[t] = []), this.curls[t].push([e, n]);\n            }\n          }, {\n            key: \"addDirection\",\n            value: function value(t, e, n) {\n              void 0 === this.directions[t] && (this.directions[t] = []), this.directions[t].push([e, n]);\n            }\n          }, {\n            key: \"setWeight\",\n            value: function value(t, e) {\n              this.weights[t] = e;\n              var n = this.weights.reduce(function (t, e) {\n                return t + e;\n              }, 0);\n              this.weightsRelative = this.weights.map(function (t) {\n                return 5 * t / n;\n              });\n            }\n          }, {\n            key: \"matchAgainst\",\n            value: function value(t, e) {\n              var n = 0;\n\n              for (var r in t) {\n                var i = t[r],\n                    o = this.curls[r];\n\n                if (void 0 !== o) {\n                  var a,\n                      l = D(o);\n\n                  try {\n                    for (l.s(); !(a = l.n()).done;) {\n                      var u = b(a.value, 2),\n                          c = u[0],\n                          f = u[1];\n\n                      if (i == c) {\n                        n += f * this.weightsRelative[r];\n                        break;\n                      }\n                    }\n                  } catch (t) {\n                    l.e(t);\n                  } finally {\n                    l.f();\n                  }\n                } else n += this.weightsRelative[r];\n              }\n\n              for (var s in e) {\n                var h = e[s],\n                    d = this.directions[s];\n\n                if (void 0 !== d) {\n                  var p,\n                      y = D(d);\n\n                  try {\n                    for (y.s(); !(p = y.n()).done;) {\n                      var g = b(p.value, 2),\n                          v = g[0],\n                          m = g[1];\n\n                      if (h == v) {\n                        n += m * this.weightsRelative[s];\n                        break;\n                      }\n                    }\n                  } catch (t) {\n                    y.e(t);\n                  } finally {\n                    y.f();\n                  }\n                } else n += this.weightsRelative[s];\n              }\n\n              return n;\n            }\n          }]) && M(e.prototype, n), t;\n        }(),\n            T = new S(\"victory\");\n\n        T.addCurl(o.Thumb, a.HalfCurl, .5), T.addCurl(o.Thumb, a.NoCurl, .5), T.addDirection(o.Thumb, l.VerticalUp, 1), T.addDirection(o.Thumb, l.DiagonalUpLeft, 1), T.addCurl(o.Index, a.NoCurl, 1), T.addDirection(o.Index, l.VerticalUp, .75), T.addDirection(o.Index, l.DiagonalUpLeft, 1), T.addCurl(o.Middle, a.NoCurl, 1), T.addDirection(o.Middle, l.VerticalUp, 1), T.addDirection(o.Middle, l.DiagonalUpLeft, .75), T.addCurl(o.Ring, a.FullCurl, 1), T.addDirection(o.Ring, l.VerticalUp, .2), T.addDirection(o.Ring, l.DiagonalUpLeft, 1), T.addDirection(o.Ring, l.HorizontalLeft, .2), T.addCurl(o.Pinky, a.FullCurl, 1), T.addDirection(o.Pinky, l.VerticalUp, .2), T.addDirection(o.Pinky, l.DiagonalUpLeft, 1), T.addDirection(o.Pinky, l.HorizontalLeft, .2), T.setWeight(o.Index, 2), T.setWeight(o.Middle, 2);\n        var C = T,\n            R = new S(\"thumbs_up\");\n        R.addCurl(o.Thumb, a.NoCurl, 1), R.addDirection(o.Thumb, l.VerticalUp, 1), R.addDirection(o.Thumb, l.DiagonalUpLeft, .25), R.addDirection(o.Thumb, l.DiagonalUpRight, .25);\n\n        for (var A = 0, L = [o.Index, o.Middle, o.Ring, o.Pinky]; A < L.length; A++) {\n          var _ = L[A];\n          R.addCurl(_, a.FullCurl, 1), R.addDirection(_, l.HorizontalLeft, 1), R.addDirection(_, l.HorizontalRight, 1);\n        }\n\n        var j = R;\n        e.default = {\n          GestureEstimator: m,\n          GestureDescription: S,\n          Finger: o,\n          FingerCurl: a,\n          FingerDirection: l,\n          Gestures: r\n        };\n      }]).default;\n    });\n  });\n  var fingerpose$1 = /*@__PURE__*/getDefaultExportFromCjs(fingerpose);\n\n  var HandsModel = /*#__PURE__*/function (_BaseModel) {\n    _inherits(HandsModel, _BaseModel);\n\n    var _super = _createSuper(HandsModel);\n\n    function HandsModel(handsfree, config) {\n      var _this5;\n\n      _classCallCheck(this, HandsModel);\n\n      _this5 = _super.call(this, handsfree, config);\n      _this5.name = 'hands';\n      _this5.palmPoints = [0, 5, 9, 13, 17];\n      _this5.gestureEstimator = new fingerpose$1.GestureEstimator([]);\n      return _this5;\n    }\n\n    _createClass(HandsModel, [{\n      key: \"loadDependencies\",\n      value: function loadDependencies(callback) {\n        var _this6 = this;\n\n        // Just load utils on client\n        if (this.handsfree.config.isClient) {\n          this.loadDependency(\"\".concat(this.handsfree.config.assetsPath, \"/@mediapipe/drawing_utils.js\"), function () {\n            _this6.onWarmUp(callback);\n          }, !!window.drawConnectors);\n          return;\n        } // Load hands\n\n\n        this.loadDependency(\"\".concat(this.handsfree.config.assetsPath, \"/@mediapipe/hands/hands.js\"), function () {\n          // Configure model\n          _this6.api = new window.Hands({\n            locateFile: function locateFile(file) {\n              return \"\".concat(_this6.handsfree.config.assetsPath, \"/@mediapipe/hands/\").concat(file);\n            }\n          });\n\n          _this6.api.setOptions(_this6.handsfree.config.hands);\n\n          _this6.api.onResults(function (results) {\n            return _this6.dataReceived(results);\n          }); // Load the media stream\n\n\n          _this6.handsfree.getUserMedia(function () {\n            // Warm up before using in loop\n            if (!_this6.handsfree.mediapipeWarmups.isWarmingUp) {\n              _this6.warmUp(callback);\n            } else {\n              _this6.handsfree.on('mediapipeWarmedUp', function () {\n                if (!_this6.handsfree.mediapipeWarmups.isWarmingUp && !_this6.handsfree.mediapipeWarmups[_this6.name]) {\n                  _this6.warmUp(callback);\n                }\n              });\n            }\n          }); // Load the hands camera module\n\n\n          _this6.loadDependency(\"\".concat(_this6.handsfree.config.assetsPath, \"/@mediapipe/drawing_utils.js\"), null, !!window.drawConnectors);\n        });\n      }\n      /**\r\n       * Warms up the model\r\n       */\n\n    }, {\n      key: \"warmUp\",\n      value: function warmUp(callback) {\n        var _this7 = this;\n\n        this.handsfree.mediapipeWarmups[this.name] = true;\n        this.handsfree.mediapipeWarmups.isWarmingUp = true;\n        this.api.send({\n          image: this.handsfree.debug.$video\n        }).then(function () {\n          _this7.handsfree.mediapipeWarmups.isWarmingUp = false;\n\n          _this7.onWarmUp(callback);\n        });\n      }\n      /**\r\n       * Called after the model has been warmed up\r\n       * - If we don't do this there will be too many initial hits and cause an error\r\n       */\n\n    }, {\n      key: \"onWarmUp\",\n      value: function onWarmUp(callback) {\n        this.dependenciesLoaded = true;\n        document.body.classList.add('handsfree-model-hands');\n        this.handsfree.emit('modelReady', this);\n        this.handsfree.emit('handsModelReady', this);\n        this.handsfree.emit('mediapipeWarmedUp', this);\n        callback && callback(this);\n      }\n      /**\r\n       * Get data\r\n       */\n\n    }, {\n      key: \"getData\",\n      value: function () {\n        var _getData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.t0 = this.dependenciesLoaded;\n\n                  if (!_context2.t0) {\n                    _context2.next = 4;\n                    break;\n                  }\n\n                  _context2.next = 4;\n                  return this.api.send({\n                    image: this.handsfree.debug.$video\n                  });\n\n                case 4:\n                  return _context2.abrupt(\"return\", this.data);\n\n                case 5:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function getData() {\n          return _getData.apply(this, arguments);\n        }\n\n        return getData;\n      }() // Called through this.api.onResults\n\n    }, {\n      key: \"dataReceived\",\n      value: function dataReceived(results) {\n        // Get center of palm\n        if (results.multiHandLandmarks) {\n          results = this.getCenterOfPalm(results);\n        } // Force handedness\n\n\n        results = this.forceHandedness(results); // Update and debug\n\n        this.data = results;\n        this.handsfree.data.hands = results;\n\n        if (this.handsfree.isDebugging) {\n          this.debug(results);\n        }\n      }\n      /**\r\n       * Forces the hands to always be in the same index\r\n       */\n\n    }, {\n      key: \"forceHandedness\",\n      value: function forceHandedness(results) {\n        // Empty landmarks\n        results.landmarks = [[], [], [], []];\n        results.landmarksVisible = [false, false, false, false];\n\n        if (!results.multiHandLandmarks) {\n          return results;\n        } // Store landmarks in the correct index\n\n\n        results.multiHandLandmarks.forEach(function (landmarks, n) {\n          var hand;\n\n          if (n < 2) {\n            hand = results.multiHandedness[n].label === 'Right' ? 0 : 1;\n          } else {\n            hand = results.multiHandedness[n].label === 'Right' ? 2 : 3;\n          }\n\n          results.landmarks[hand] = landmarks;\n          results.landmarksVisible[hand] = true;\n        });\n        return results;\n      }\n      /**\r\n       * Calculates the center of the palm\r\n       */\n\n    }, {\n      key: \"getCenterOfPalm\",\n      value: function getCenterOfPalm(results) {\n        var _this8 = this;\n\n        results.multiHandLandmarks.forEach(function (hand, n) {\n          var x = 0;\n          var y = 0;\n\n          _this8.palmPoints.forEach(function (i) {\n            x += hand[i].x;\n            y += hand[i].y;\n          });\n\n          x /= _this8.palmPoints.length;\n          y /= _this8.palmPoints.length;\n          results.multiHandLandmarks[n][21] = {\n            x: x,\n            y: y\n          };\n        });\n        return results;\n      }\n      /**\r\n       * Debugs the hands model\r\n       */\n\n    }, {\n      key: \"debug\",\n      value: function debug(results) {\n        // Bail if drawing helpers haven't loaded\n        if (typeof drawConnectors === 'undefined') return; // Clear the canvas\n\n        this.handsfree.debug.context.hands.clearRect(0, 0, this.handsfree.debug.$canvas.hands.width, this.handsfree.debug.$canvas.hands.height); // Draw skeletons\n\n        if (results.multiHandLandmarks) {\n          var _iterator = _createForOfIteratorHelper(results.multiHandLandmarks),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var landmarks = _step.value;\n              drawConnectors(this.handsfree.debug.context.hands, landmarks, HAND_CONNECTIONS, {\n                color: '#00FF00',\n                lineWidth: 5\n              });\n              drawLandmarks(this.handsfree.debug.context.hands, landmarks, {\n                color: '#FF0000',\n                lineWidth: 2\n              });\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n      /**\r\n       * Updates the gesture estimator\r\n       */\n\n    }, {\n      key: \"updateGestureEstimator\",\n      value: function updateGestureEstimator() {\n        var _this9 = this;\n\n        var activeGestures = [];\n        var gestureDescriptions = []; // Build the gesture descriptions\n\n        this.gestures.forEach(function (name) {\n          if (!_this9.handsfree.gesture[name].enabled) return;\n          activeGestures.push(name); // Loop through the description and compile it\n\n          if (!_this9.handsfree.gesture[name].compiledDescription && _this9.handsfree.gesture[name].enabled) {\n            var description = new fingerpose$1.GestureDescription(name);\n\n            _this9.handsfree.gesture[name].description.forEach(function (pose) {\n              // Build the description\n              switch (pose[0]) {\n                case 'addCurl':\n                  description[pose[0]](fingerpose$1.Finger[pose[1]], fingerpose$1.FingerCurl[pose[2]], pose[3]);\n                  break;\n\n                case 'addDirection':\n                  description[pose[0]](fingerpose$1.Finger[pose[1]], fingerpose$1.FingerDirection[pose[2]], pose[3]);\n                  break;\n\n                case 'setWeight':\n                  description[pose[0]](fingerpose$1.Finger[pose[1]], pose[2]);\n                  break;\n              }\n            });\n\n            _this9.handsfree.gesture[name].compiledDescription = description;\n          }\n        }); // Create the gesture estimator\n\n        activeGestures.forEach(function (gesture) {\n          gestureDescriptions.push(_this9.handsfree.gesture[gesture].compiledDescription);\n        });\n\n        if (activeGestures.length) {\n          this.gestureEstimator = new fingerpose$1.GestureEstimator(gestureDescriptions);\n        }\n      }\n      /**\r\n       * Gets current gesture\r\n       */\n\n    }, {\n      key: \"getGesture\",\n      value: function getGesture() {\n        var _this10 = this;\n\n        var gestures = [null, null, null, null];\n        this.data.landmarks.forEach(function (landmarksObj, hand) {\n          if (_this10.data.landmarksVisible[hand]) {\n            // Convert object to array\n            var landmarks = [];\n\n            for (var i = 0; i < 21; i++) {\n              landmarks.push([landmarksObj[i].x * window.outerWidth, landmarksObj[i].y * window.outerHeight, 0]);\n            } // Estimate\n\n\n            var estimate = _this10.gestureEstimator.estimate(landmarks, 7.5);\n\n            if (estimate.gestures.length) {\n              gestures[hand] = estimate.gestures.reduce(function (p, c) {\n                var requiredConfidence = _this10.handsfree.gesture[c.name].confidence;\n                return c.confidence >= requiredConfidence && c.confidence > p.confidence ? c : p;\n              });\n            } else {\n              gestures[hand] = {\n                name: '',\n                confidence: 0\n              };\n            } // Must pass confidence\n\n\n            if (gestures[hand].name) {\n              var requiredConfidence = _this10.handsfree.gesture[gestures[hand].name].confidence;\n\n              if (gestures[hand].confidence < requiredConfidence) {\n                gestures[hand] = {\n                  name: '',\n                  confidence: 0\n                };\n              }\n            }\n\n            gestures[hand].pose = estimate.poseData;\n          }\n        });\n        return gestures;\n      }\n    }]);\n\n    return HandsModel;\n  }(BaseModel);\n\n  var FacemeshModel = /*#__PURE__*/function (_BaseModel2) {\n    _inherits(FacemeshModel, _BaseModel2);\n\n    var _super2 = _createSuper(FacemeshModel);\n\n    function FacemeshModel(handsfree, config) {\n      var _this11;\n\n      _classCallCheck(this, FacemeshModel);\n\n      _this11 = _super2.call(this, handsfree, config);\n      _this11.name = 'facemesh';\n      _this11.isWarmedUp = false;\n      return _this11;\n    }\n\n    _createClass(FacemeshModel, [{\n      key: \"loadDependencies\",\n      value: function loadDependencies(callback) {\n        var _this12 = this;\n\n        // Just load utils on client\n        if (this.handsfree.config.isClient) {\n          this.loadDependency(\"\".concat(this.handsfree.config.assetsPath, \"/@mediapipe/drawing_utils.js\"), function () {\n            _this12.onWarmUp(callback);\n          }, !!window.drawConnectors);\n          return;\n        } // Load facemesh\n\n\n        this.loadDependency(\"\".concat(this.handsfree.config.assetsPath, \"/@mediapipe/face_mesh/face_mesh.js\"), function () {\n          // Configure model\n          _this12.api = new window.FaceMesh({\n            locateFile: function locateFile(file) {\n              return \"\".concat(_this12.handsfree.config.assetsPath, \"/@mediapipe/face_mesh/\").concat(file);\n            }\n          });\n\n          _this12.api.setOptions(_this12.handsfree.config.facemesh);\n\n          _this12.api.onResults(function (results) {\n            return _this12.dataReceived(results);\n          }); // Load the media stream\n\n\n          _this12.handsfree.getUserMedia(function () {\n            // Warm up before using in loop\n            if (!_this12.handsfree.mediapipeWarmups.isWarmingUp) {\n              _this12.warmUp(callback);\n            } else {\n              _this12.handsfree.on('mediapipeWarmedUp', function () {\n                if (!_this12.handsfree.mediapipeWarmups.isWarmingUp && !_this12.handsfree.mediapipeWarmups[_this12.name]) {\n                  _this12.warmUp(callback);\n                }\n              });\n            }\n          }); // Load the hands camera module\n\n\n          _this12.loadDependency(\"\".concat(_this12.handsfree.config.assetsPath, \"/@mediapipe/drawing_utils.js\"), null, !!window.drawConnectors);\n        });\n      }\n      /**\r\n       * Warms up the model\r\n       */\n\n    }, {\n      key: \"warmUp\",\n      value: function warmUp(callback) {\n        var _this13 = this;\n\n        this.handsfree.mediapipeWarmups[this.name] = true;\n        this.handsfree.mediapipeWarmups.isWarmingUp = true;\n        this.api.send({\n          image: this.handsfree.debug.$video\n        }).then(function () {\n          _this13.handsfree.mediapipeWarmups.isWarmingUp = false;\n\n          _this13.onWarmUp(callback);\n        });\n      }\n      /**\r\n       * Called after the model has been warmed up\r\n       * - If we don't do this there will be too many initial hits and cause an error\r\n       */\n\n    }, {\n      key: \"onWarmUp\",\n      value: function onWarmUp(callback) {\n        this.dependenciesLoaded = true;\n        document.body.classList.add('handsfree-model-facemesh');\n        this.handsfree.emit('modelReady', this);\n        this.handsfree.emit('facemeshModelReady', this);\n        this.handsfree.emit('mediapipeWarmedUp', this);\n        callback && callback(this);\n      }\n      /**\r\n       * Get data\r\n       */\n\n    }, {\n      key: \"getData\",\n      value: function () {\n        var _getData2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.t0 = this.dependenciesLoaded;\n\n                  if (!_context3.t0) {\n                    _context3.next = 4;\n                    break;\n                  }\n\n                  _context3.next = 4;\n                  return this.api.send({\n                    image: this.handsfree.debug.$video\n                  });\n\n                case 4:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n\n        function getData() {\n          return _getData2.apply(this, arguments);\n        }\n\n        return getData;\n      }() // Called through this.api.onResults\n\n    }, {\n      key: \"dataReceived\",\n      value: function dataReceived(results) {\n        this.data = results;\n        this.handsfree.data.facemesh = results;\n\n        if (this.handsfree.isDebugging) {\n          this.debug(results);\n        }\n      }\n      /**\r\n       * Debugs the facemesh model\r\n       */\n\n    }, {\n      key: \"debug\",\n      value: function debug(results) {\n        // Bail if drawing helpers haven't loaded\n        if (typeof drawConnectors === 'undefined') return;\n        this.handsfree.debug.context.facemesh.clearRect(0, 0, this.handsfree.debug.$canvas.facemesh.width, this.handsfree.debug.$canvas.facemesh.height);\n\n        if (results.multiFaceLandmarks) {\n          var _iterator2 = _createForOfIteratorHelper(results.multiFaceLandmarks),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var landmarks = _step2.value;\n              drawConnectors(this.handsfree.debug.context.facemesh, landmarks, FACEMESH_TESSELATION, {\n                color: '#C0C0C070',\n                lineWidth: 1\n              });\n              drawConnectors(this.handsfree.debug.context.facemesh, landmarks, FACEMESH_RIGHT_EYE, {\n                color: '#FF3030'\n              });\n              drawConnectors(this.handsfree.debug.context.facemesh, landmarks, FACEMESH_RIGHT_EYEBROW, {\n                color: '#FF3030'\n              });\n              drawConnectors(this.handsfree.debug.context.facemesh, landmarks, FACEMESH_LEFT_EYE, {\n                color: '#30FF30'\n              });\n              drawConnectors(this.handsfree.debug.context.facemesh, landmarks, FACEMESH_LEFT_EYEBROW, {\n                color: '#30FF30'\n              });\n              drawConnectors(this.handsfree.debug.context.facemesh, landmarks, FACEMESH_FACE_OVAL, {\n                color: '#E0E0E0'\n              });\n              drawConnectors(this.handsfree.debug.context.facemesh, landmarks, FACEMESH_LIPS, {\n                color: '#E0E0E0'\n              });\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      }\n    }]);\n\n    return FacemeshModel;\n  }(BaseModel);\n\n  var PoseModel = /*#__PURE__*/function (_BaseModel3) {\n    _inherits(PoseModel, _BaseModel3);\n\n    var _super3 = _createSuper(PoseModel);\n\n    function PoseModel(handsfree, config) {\n      var _this14;\n\n      _classCallCheck(this, PoseModel);\n\n      _this14 = _super3.call(this, handsfree, config);\n      _this14.name = 'pose'; // Without this the loading event will happen before the first frame\n\n      _this14.hasLoadedAndRun = false;\n      _this14.palmPoints = [0, 1, 2, 5, 9, 13, 17];\n      return _this14;\n    }\n\n    _createClass(PoseModel, [{\n      key: \"loadDependencies\",\n      value: function loadDependencies(callback) {\n        var _this15 = this;\n\n        // Just load utils on client\n        if (this.handsfree.config.isClient) {\n          this.loadDependency(\"\".concat(this.handsfree.config.assetsPath, \"/@mediapipe/drawing_utils.js\"), function () {\n            _this15.onWarmUp(callback);\n          }, !!window.drawConnectors);\n          return;\n        } // Load pose\n\n\n        this.loadDependency(\"\".concat(this.handsfree.config.assetsPath, \"/@mediapipe/pose/pose.js\"), function () {\n          _this15.api = new window.Pose({\n            locateFile: function locateFile(file) {\n              return \"\".concat(_this15.handsfree.config.assetsPath, \"/@mediapipe/pose/\").concat(file);\n            }\n          });\n\n          _this15.api.setOptions(_this15.handsfree.config.pose);\n\n          _this15.api.onResults(function (results) {\n            return _this15.dataReceived(results);\n          }); // Load the media stream\n\n\n          _this15.handsfree.getUserMedia(function () {\n            // Warm up before using in loop\n            if (!_this15.handsfree.mediapipeWarmups.isWarmingUp) {\n              _this15.warmUp(callback);\n            } else {\n              _this15.handsfree.on('mediapipeWarmedUp', function () {\n                if (!_this15.handsfree.mediapipeWarmups.isWarmingUp && !_this15.handsfree.mediapipeWarmups[_this15.name]) {\n                  _this15.warmUp(callback);\n                }\n              });\n            }\n          }); // Load the hands camera module\n\n\n          _this15.loadDependency(\"\".concat(_this15.handsfree.config.assetsPath, \"/@mediapipe/drawing_utils.js\"), null, !!window.drawConnectors);\n        });\n      }\n      /**\r\n       * Warms up the model\r\n       */\n\n    }, {\n      key: \"warmUp\",\n      value: function warmUp(callback) {\n        var _this16 = this;\n\n        this.handsfree.mediapipeWarmups[this.name] = true;\n        this.handsfree.mediapipeWarmups.isWarmingUp = true;\n        this.api.send({\n          image: this.handsfree.debug.$video\n        }).then(function () {\n          _this16.handsfree.mediapipeWarmups.isWarmingUp = false;\n\n          _this16.onWarmUp(callback);\n        });\n      }\n      /**\r\n       * Called after the model has been warmed up\r\n       * - If we don't do this there will be too many initial hits and cause an error\r\n       */\n\n    }, {\n      key: \"onWarmUp\",\n      value: function onWarmUp(callback) {\n        this.dependenciesLoaded = true;\n        document.body.classList.add('handsfree-model-pose');\n        this.handsfree.emit('modelReady', this);\n        this.handsfree.emit('poseModelReady', this);\n        this.handsfree.emit('mediapipeWarmedUp', this);\n        callback && callback(this);\n      }\n      /**\r\n       * Get data\r\n       */\n\n    }, {\n      key: \"getData\",\n      value: function () {\n        var _getData3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n          return regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.t0 = this.dependenciesLoaded;\n\n                  if (!_context4.t0) {\n                    _context4.next = 4;\n                    break;\n                  }\n\n                  _context4.next = 4;\n                  return this.api.send({\n                    image: this.handsfree.debug.$video\n                  });\n\n                case 4:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n\n        function getData() {\n          return _getData3.apply(this, arguments);\n        }\n\n        return getData;\n      }() // Called through this.api.onResults\n\n    }, {\n      key: \"dataReceived\",\n      value: function dataReceived(results) {\n        this.data = results;\n        this.handsfree.data.pose = results;\n\n        if (this.handsfree.isDebugging) {\n          this.debug(results);\n        }\n      }\n      /**\r\n       * Debugs the pose model\r\n       */\n\n    }, {\n      key: \"debug\",\n      value: function debug(results) {\n        this.handsfree.debug.context.pose.clearRect(0, 0, this.handsfree.debug.$canvas.pose.width, this.handsfree.debug.$canvas.pose.height);\n\n        if (results.poseLandmarks) {\n          drawConnectors(this.handsfree.debug.context.pose, results.poseLandmarks, POSE_CONNECTIONS, {\n            color: '#00FF00',\n            lineWidth: 4\n          });\n          drawLandmarks(this.handsfree.debug.context.pose, results.poseLandmarks, {\n            color: '#FF0000',\n            lineWidth: 2\n          });\n        }\n      }\n    }]);\n\n    return PoseModel;\n  }(BaseModel);\n  /**\r\n   *  This model is not currently active\r\n   */\n\n\n  var HandposeModel = /*#__PURE__*/function (_BaseModel4) {\n    _inherits(HandposeModel, _BaseModel4);\n\n    var _super4 = _createSuper(HandposeModel);\n\n    function HandposeModel(handsfree, config) {\n      var _this17;\n\n      _classCallCheck(this, HandposeModel);\n\n      _this17 = _super4.call(this, handsfree, config);\n      _this17.name = 'handpose'; // Various THREE variables\n\n      _this17.three = {\n        scene: null,\n        camera: null,\n        renderer: null,\n        meshes: []\n      };\n      _this17.normalized = []; // landmark indices that represent the palm\n      // 8 = Index finger tip\n      // 12 = Middle finger tip\n\n      _this17.palmPoints = [0, 1, 2, 5, 9, 13, 17];\n      _this17.gestureEstimator = new fingerpose$1.GestureEstimator([]);\n      return _this17;\n    }\n\n    _createClass(HandposeModel, [{\n      key: \"loadDependencies\",\n      value: function loadDependencies(callback) {\n        var _this18 = this;\n\n        this.loadDependency(\"\".concat(this.handsfree.config.assetsPath, \"/three/three.min.js\"), function () {\n          _this18.loadDependency(\"\".concat(_this18.handsfree.config.assetsPath, \"/@tensorflow/tf-core.js\"), function () {\n            _this18.loadDependency(\"\".concat(_this18.handsfree.config.assetsPath, \"/@tensorflow/tf-converter.js\"), function () {\n              _this18.loadDependency(\"\".concat(_this18.handsfree.config.assetsPath, \"/@tensorflow/tf-backend-\").concat(_this18.handsfree.config.handpose.backend, \".js\"), function () {\n                _this18.loadDependency(\"\".concat(_this18.handsfree.config.assetsPath, \"/@tensorflow-models/handpose/handpose.js\"), function () {\n                  _this18.handsfree.getUserMedia( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n                    return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            _context5.next = 2;\n                            return window.tf.setBackend(_this18.handsfree.config.handpose.backend);\n\n                          case 2:\n                            _context5.next = 4;\n                            return handpose.load(_this18.handsfree.config.handpose.model);\n\n                          case 4:\n                            _this18.api = _context5.sent;\n\n                            _this18.setup3D();\n\n                            callback && callback(_this18);\n                            _this18.dependenciesLoaded = true;\n\n                            _this18.handsfree.emit('modelReady', _this18);\n\n                            _this18.handsfree.emit('handposeModelReady', _this18);\n\n                            document.body.classList.add('handsfree-model-handpose');\n\n                          case 11:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5);\n                  })));\n                });\n              });\n            });\n          }, !!window.tf);\n        }, !!window.THREE);\n      }\n      /**\r\n       * Runs inference and sets up other data\r\n       */\n\n    }, {\n      key: \"getData\",\n      value: function () {\n        var _getData4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {\n          var predictions;\n          return regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  if (this.handsfree.debug.$video) {\n                    _context6.next = 2;\n                    break;\n                  }\n\n                  return _context6.abrupt(\"return\");\n\n                case 2:\n                  _context6.next = 4;\n                  return this.api.estimateHands(this.handsfree.debug.$video);\n\n                case 4:\n                  predictions = _context6.sent;\n                  this.handsfree.data.handpose = this.data = _objectSpread(_objectSpread({}, predictions[0]), {}, {\n                    normalized: this.normalized,\n                    meshes: this.three.meshes\n                  });\n\n                  if (predictions[0]) {\n                    this.updateMeshes(this.data);\n                  }\n\n                  this.three.renderer.render(this.three.scene, this.three.camera);\n                  return _context6.abrupt(\"return\", this.data);\n\n                case 9:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, this);\n        }));\n\n        function getData() {\n          return _getData4.apply(this, arguments);\n        }\n\n        return getData;\n      }()\n      /**\r\n       * Sets up the 3D environment\r\n       */\n\n    }, {\n      key: \"setup3D\",\n      value: function setup3D() {\n        // Setup Three\n        this.three = {\n          scene: new window.THREE.Scene(),\n          camera: new window.THREE.PerspectiveCamera(90, window.outerWidth / window.outerHeight, 0.1, 1000),\n          renderer: new THREE.WebGLRenderer({\n            alpha: true,\n            canvas: this.handsfree.debug.$canvas.handpose\n          }),\n          meshes: []\n        };\n        this.three.renderer.setSize(window.outerWidth, window.outerHeight);\n        this.three.camera.position.z = this.handsfree.debug.$video.videoWidth / 4;\n        this.three.camera.lookAt(new window.THREE.Vector3(0, 0, 0)); // Camera plane\n\n        this.three.screen = new window.THREE.Mesh(new window.THREE.BoxGeometry(window.outerWidth, window.outerHeight, 1), new window.THREE.MeshNormalMaterial());\n        this.three.screen.position.z = 300;\n        this.three.scene.add(this.three.screen); // Camera raycaster\n\n        this.three.raycaster = new window.THREE.Raycaster();\n        this.three.arrow = new window.THREE.ArrowHelper(this.three.raycaster.ray.direction, this.three.raycaster.ray.origin, 300, 0xff0000);\n        this.three.scene.add(this.three.arrow); // Create model representations (one for each keypoint)\n\n        for (var i = 0; i < 21; i++) {\n          var _this$getLandmarkProp = this.getLandmarkProperty(i),\n              isPalm = _this$getLandmarkProp.isPalm;\n\n          var _obj = new window.THREE.Object3D(); // a parent object to facilitate rotation/scaling\n          // we make each bone a cylindrical shape, but you can use your own models here too\n\n\n          var _geometry = new window.THREE.CylinderGeometry(isPalm ? 5 : 10, 5, 1);\n\n          var _material = new window.THREE.MeshNormalMaterial();\n\n          var _mesh = new window.THREE.Mesh(_geometry, _material);\n\n          _mesh.rotation.x = Math.PI / 2;\n\n          _obj.add(_mesh);\n\n          this.three.scene.add(_obj);\n          this.three.meshes.push(_obj); // uncomment this to help identify joints\n          // if (i === 4) {\n          //   mesh.material.transparent = true\n          //   mesh.material.opacity = 0\n          // }\n        } // Create center of palm\n\n\n        var obj = new window.THREE.Object3D();\n        var geometry = new window.THREE.CylinderGeometry(5, 5, 1);\n        var material = new window.THREE.MeshNormalMaterial();\n        var mesh = new window.THREE.Mesh(geometry, material);\n        mesh.rotation.x = Math.PI / 2;\n        this.three.centerPalmObj = obj;\n        obj.add(mesh);\n        this.three.scene.add(obj);\n        this.three.meshes.push(obj);\n        this.three.screen.visible = false;\n      } // compute some metadata given a landmark index\n      // - is the landmark a palm keypoint or a finger keypoint?\n      // - what's the next landmark to connect to if we're drawing a bone?\n\n    }, {\n      key: \"getLandmarkProperty\",\n      value: function getLandmarkProperty(i) {\n        var palms = [0, 1, 2, 5, 9, 13, 17]; //landmark indices that represent the palm\n\n        var idx = palms.indexOf(i);\n        var isPalm = idx != -1;\n        var next; // who to connect with?\n\n        if (!isPalm) {\n          // connect with previous finger landmark if it's a finger landmark\n          next = i - 1;\n        } else {\n          // connect with next palm landmark if it's a palm landmark\n          next = palms[(idx + 1) % palms.length];\n        }\n\n        return {\n          isPalm: isPalm,\n          next: next\n        };\n      }\n      /**\r\n       * update threejs object position and orientation from the detected hand pose\r\n       * threejs has a \"scene\" model, so we don't have to specify what to draw each frame,\r\n       * instead we put objects at right positions and threejs renders them all\r\n       * @param {*} hand \r\n       */\n\n    }, {\n      key: \"updateMeshes\",\n      value: function updateMeshes(hand) {\n        for (var i = 0; i < this.three.meshes.length - 1\n        /* palmbase */\n        ; i++) {\n          var _this$getLandmarkProp2 = this.getLandmarkProperty(i),\n              next = _this$getLandmarkProp2.next;\n\n          var p0 = this.webcam2space.apply(this, _toConsumableArray(hand.landmarks[i])); // one end of the bone\n\n          var p1 = this.webcam2space.apply(this, _toConsumableArray(hand.landmarks[next])); // the other end of the bone\n          // compute the center of the bone (midpoint)\n\n          var mid = p0.clone().lerp(p1, 0.5);\n          this.three.meshes[i].position.set(mid.x, mid.y, mid.z);\n          this.normalized[i] = [this.handsfree.normalize(p0.x, this.handsfree.debug.$video.videoWidth / -2, this.handsfree.debug.$video.videoWidth / 2), this.handsfree.normalize(p0.y, this.handsfree.debug.$video.videoHeight / -2, this.handsfree.debug.$video.videoHeight / 2), this.three.meshes[i].position.z]; // compute the length of the bone\n\n          this.three.meshes[i].scale.z = p0.distanceTo(p1); // compute orientation of the bone\n\n          this.three.meshes[i].lookAt(p1);\n\n          if (i === 8) {\n            this.three.arrow.position.set(mid.x, mid.y, mid.z);\n            var direction = new window.THREE.Vector3().subVectors(p0, mid);\n            this.three.arrow.setDirection(direction.normalize());\n            this.three.arrow.setLength(800);\n            this.three.arrow.direction = direction;\n          }\n        }\n\n        this.updateCenterPalmMesh(hand);\n      }\n      /**\r\n       * Update the palm\r\n       */\n\n    }, {\n      key: \"updateCenterPalmMesh\",\n      value: function updateCenterPalmMesh(hand) {\n        var _this19 = this;\n\n        var points = [];\n        var mid = {\n          x: 0,\n          y: 0,\n          z: 0\n        }; // Get position for the palm\n\n        this.palmPoints.forEach(function (i, n) {\n          points.push(_this19.webcam2space.apply(_this19, _toConsumableArray(hand.landmarks[i])));\n          mid.x += points[n].x;\n          mid.y += points[n].y;\n          mid.z += points[n].z;\n        });\n        mid.x = mid.x / this.palmPoints.length;\n        mid.y = mid.y / this.palmPoints.length;\n        mid.z = mid.z / this.palmPoints.length;\n        this.three.centerPalmObj.position.set(mid.x, mid.y, mid.z);\n        this.three.centerPalmObj.scale.z = 10;\n        this.three.centerPalmObj.rotation.x = this.three.meshes[12].rotation.x - Math.PI / 2;\n        this.three.centerPalmObj.rotation.y = -this.three.meshes[12].rotation.y;\n        this.three.centerPalmObj.rotation.z = this.three.meshes[12].rotation.z;\n      } // transform webcam coordinates to threejs 3d coordinates\n\n    }, {\n      key: \"webcam2space\",\n      value: function webcam2space(x, y, z) {\n        return new window.THREE.Vector3(x - this.handsfree.debug.$video.videoWidth / 2, -(y - this.handsfree.debug.$video.videoHeight / 2), // in threejs, +y is up\n        -z);\n      }\n      /**\r\n       * Updates the gesture estimator\r\n       */\n\n    }, {\n      key: \"updateGestureEstimator\",\n      value: function updateGestureEstimator() {\n        var _this20 = this;\n\n        var activeGestures = [];\n        var gestureDescriptions = []; // Build the gesture descriptions\n\n        this.gestures.forEach(function (name) {\n          _this20.handsfree.gesture[name].enabled && activeGestures.push(name); // Loop through the description and compile it\n\n          if (!_this20.handsfree.gesture[name].compiledDescription && _this20.handsfree.gesture[name].enabled) {\n            var description = new fingerpose$1.GestureDescription(name);\n\n            _this20.handsfree.gesture[name].description.forEach(function (pose) {\n              // Build the description\n              switch (pose[0]) {\n                case 'addCurl':\n                  description[pose[0]](fingerpose$1.Finger[pose[1]], fingerpose$1.FingerCurl[pose[2]], pose[3]);\n                  break;\n\n                case 'addDirection':\n                  description[pose[0]](fingerpose$1.Finger[pose[1]], fingerpose$1.FingerDirection[pose[2]], pose[3]);\n                  break;\n\n                case 'setWeight':\n                  description[pose[0]](fingerpose$1.Finger[pose[1]], pose[2]);\n                  break;\n              }\n            });\n\n            _this20.handsfree.gesture[name].compiledDescription = description;\n          }\n        }); // Create the gesture estimator\n\n        activeGestures.forEach(function (gesture) {\n          gestureDescriptions.push(_this20.handsfree.gesture[gesture].compiledDescription);\n        });\n\n        if (activeGestures.length) {\n          this.gestureEstimator = new fingerpose$1.GestureEstimator(gestureDescriptions);\n        }\n      }\n      /**\r\n       * Gets current gesture\r\n       */\n\n    }, {\n      key: \"getGesture\",\n      value: function getGesture() {\n        var gesture = null;\n\n        if (this.data.landmarks && this.gestureEstimator) {\n          var estimate = this.gestureEstimator.estimate(this.data.landmarks, 7.5);\n\n          if (estimate.gestures.length) {\n            gesture = estimate.gestures.reduce(function (p, c) {\n              return p.confidence > c.confidence ? p : c;\n            });\n          }\n        }\n\n        return gesture;\n      }\n    }]);\n\n    return HandposeModel;\n  }(BaseModel);\n\n  var WebojiModel = /*#__PURE__*/function (_BaseModel5) {\n    _inherits(WebojiModel, _BaseModel5);\n\n    var _super5 = _createSuper(WebojiModel);\n\n    function WebojiModel(handsfree, config) {\n      var _this21;\n\n      _classCallCheck(this, WebojiModel);\n\n      _this21 = _super5.call(this, handsfree, config);\n      _this21.name = 'weboji';\n      return _this21;\n    }\n\n    _createClass(WebojiModel, [{\n      key: \"loadDependencies\",\n      value: function loadDependencies(callback) {\n        var _this22 = this;\n\n        // Just load utils on client\n        if (this.handsfree.config.isClient) {\n          this.onReady(callback);\n          return;\n        } // Load weboji\n\n\n        this.loadDependency(\"\".concat(this.handsfree.config.assetsPath, \"/jeeliz/jeelizFaceTransfer.js\"), function () {\n          var url = _this22.handsfree.config.assetsPath + '/jeeliz/jeelizFaceTransferNNC.json';\n          _this22.api = window.JEEFACETRANSFERAPI;\n          fetch(url).then(function (model) {\n            return model.json();\n          }) // Next, let's initialize the weboji tracker API\n          .then(function (model) {\n            _this22.api.init({\n              canvasId: \"handsfree-canvas-weboji-\".concat(_this22.handsfree.id),\n              NNC: JSON.stringify(model),\n              videoSettings: _this22.handsfree.config.weboji.videoSettings,\n              callbackReady: function callbackReady() {\n                return _this22.onReady(callback);\n              }\n            });\n          }).catch(function (ev) {\n            console.log(ev);\n            console.error(\"Couldn't load weboji tracking model at \".concat(url));\n\n            _this22.handsfree.emit('modelError', ev);\n          });\n        });\n      }\n    }, {\n      key: \"onReady\",\n      value: function onReady(callback) {\n        this.dependenciesLoaded = true;\n        this.handsfree.emit('modelReady', this);\n        this.handsfree.emit('webojiModelReady', this);\n        document.body.classList.add('handsfree-model-weboji');\n        callback && callback(this);\n      }\n    }, {\n      key: \"getData\",\n      value: function getData() {\n        // Core\n        this.data.rotation = this.api.get_rotationStabilized();\n        this.data.translation = this.api.get_positionScale();\n        this.data.morphs = this.api.get_morphTargetInfluencesStabilized(); // Helpers\n\n        this.data.state = this.getStates();\n        this.data.degree = this.getDegrees();\n        this.data.isDetected = this.api.is_detected();\n        this.handsfree.data.weboji = this.data;\n        return this.data;\n      }\n      /**\r\n       * Helpers for getting degrees\r\n       */\n\n    }, {\n      key: \"getDegrees\",\n      value: function getDegrees() {\n        return [this.data.rotation[0] * 180 / Math.PI, this.data.rotation[1] * 180 / Math.PI, this.data.rotation[2] * 180 / Math.PI];\n      }\n      /**\r\n       * Sets some stateful helpers\r\n       */\n\n    }, {\n      key: \"getStates\",\n      value: function getStates() {\n        /**\r\n         * Handles extra calculations for weboji morphs\r\n         */\n        var morphs = this.data.morphs;\n        var state = this.data.state || {}; // Smiles\n\n        state.smileRight = morphs[0] > this.handsfree.config.weboji.morphs.threshold.smileRight;\n        state.smileLeft = morphs[1] > this.handsfree.config.weboji.morphs.threshold.smileLeft;\n        state.smile = state.smileRight && state.smileLeft;\n        state.smirk = state.smileRight && !state.smileLeft || !state.smileRight && state.smileLeft;\n        state.pursed = morphs[7] > this.handsfree.config.weboji.morphs.threshold.mouthRound; // Eyebrows\n\n        state.browLeftUp = morphs[4] > this.handsfree.config.weboji.morphs.threshold.browLeftUp;\n        state.browRightUp = morphs[5] > this.handsfree.config.weboji.morphs.threshold.browRightUp;\n        state.browsUp = morphs[4] > this.handsfree.config.weboji.morphs.threshold.browLeftUp && morphs[5] > this.handsfree.config.weboji.morphs.threshold.browLeftUp;\n        state.browLeftDown = morphs[2] > this.handsfree.config.weboji.morphs.threshold.browLeftDown;\n        state.browRightDown = morphs[3] > this.handsfree.config.weboji.morphs.threshold.browRightDown;\n        state.browsDown = morphs[2] > this.handsfree.config.weboji.morphs.threshold.browLeftDown && morphs[3] > this.handsfree.config.weboji.morphs.threshold.browLeftDown;\n        state.browsUpDown = state.browLeftDown && state.browRightUp || state.browRightDown && state.browLeftUp; // Eyes\n\n        state.eyeLeftClosed = morphs[8] > this.handsfree.config.weboji.morphs.threshold.eyeLeftClosed;\n        state.eyeRightClosed = morphs[9] > this.handsfree.config.weboji.morphs.threshold.eyeRightClosed;\n        state.eyesClosed = state.eyeLeftClosed && state.eyeRightClosed; // Mouth\n\n        state.mouthClosed = morphs[6] === 0;\n        state.mouthOpen = morphs[6] > this.handsfree.config.weboji.morphs.threshold.mouthOpen;\n        return state;\n      }\n    }]);\n\n    return WebojiModel;\n  }(BaseModel);\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n\n\n  function listCacheClear() {\n    this.__data__ = [];\n    this.size = 0;\n  }\n\n  var _listCacheClear = listCacheClear;\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n\n  function eq(value, other) {\n    return value === other || value !== value && other !== other;\n  }\n\n  var eq_1 = eq;\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n\n  function assocIndexOf(array, key) {\n    var length = array.length;\n\n    while (length--) {\n      if (eq_1(array[length][0], key)) {\n        return length;\n      }\n    }\n\n    return -1;\n  }\n\n  var _assocIndexOf = assocIndexOf;\n  /** Used for built-in method references. */\n\n  var arrayProto = Array.prototype;\n  /** Built-in value references. */\n\n  var splice = arrayProto.splice;\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n  function listCacheDelete(key) {\n    var data = this.__data__,\n        index = _assocIndexOf(data, key);\n\n    if (index < 0) {\n      return false;\n    }\n\n    var lastIndex = data.length - 1;\n\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n\n    --this.size;\n    return true;\n  }\n\n  var _listCacheDelete = listCacheDelete;\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n  function listCacheGet(key) {\n    var data = this.__data__,\n        index = _assocIndexOf(data, key);\n\n    return index < 0 ? undefined : data[index][1];\n  }\n\n  var _listCacheGet = listCacheGet;\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n  function listCacheHas(key) {\n    return _assocIndexOf(this.__data__, key) > -1;\n  }\n\n  var _listCacheHas = listCacheHas;\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n        index = _assocIndexOf(data, key);\n\n    if (index < 0) {\n      ++this.size;\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n\n    return this;\n  }\n\n  var _listCacheSet = listCacheSet;\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function ListCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  } // Add methods to `ListCache`.\n\n\n  ListCache.prototype.clear = _listCacheClear;\n  ListCache.prototype['delete'] = _listCacheDelete;\n  ListCache.prototype.get = _listCacheGet;\n  ListCache.prototype.has = _listCacheHas;\n  ListCache.prototype.set = _listCacheSet;\n  var _ListCache = ListCache;\n  /**\n   * Removes all key-value entries from the stack.\n   *\n   * @private\n   * @name clear\n   * @memberOf Stack\n   */\n\n  function stackClear() {\n    this.__data__ = new _ListCache();\n    this.size = 0;\n  }\n\n  var _stackClear = stackClear;\n  /**\n   * Removes `key` and its value from the stack.\n   *\n   * @private\n   * @name delete\n   * @memberOf Stack\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n  function stackDelete(key) {\n    var data = this.__data__,\n        result = data['delete'](key);\n    this.size = data.size;\n    return result;\n  }\n\n  var _stackDelete = stackDelete;\n  /**\n   * Gets the stack value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Stack\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n  function stackGet(key) {\n    return this.__data__.get(key);\n  }\n\n  var _stackGet = stackGet;\n  /**\n   * Checks if a stack value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Stack\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n  function stackHas(key) {\n    return this.__data__.has(key);\n  }\n\n  var _stackHas = stackHas;\n  /** Detect free variable `global` from Node.js. */\n\n  var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n  var _freeGlobal = freeGlobal;\n  /** Detect free variable `self`. */\n\n  var freeSelf = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\n  /** Used as a reference to the global object. */\n\n  var root = _freeGlobal || freeSelf || Function('return this')();\n  var _root = root;\n  /** Built-in value references. */\n\n  var Symbol$1 = _root.Symbol;\n  var _Symbol = Symbol$1;\n  /** Used for built-in method references. */\n\n  var objectProto = Object.prototype;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty = objectProto.hasOwnProperty;\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n\n  var nativeObjectToString = objectProto.toString;\n  /** Built-in value references. */\n\n  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n  /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */\n\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty.call(value, symToStringTag),\n        tag = value[symToStringTag];\n\n    try {\n      value[symToStringTag] = undefined;\n      var unmasked = true;\n    } catch (e) {}\n\n    var result = nativeObjectToString.call(value);\n\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag] = tag;\n      } else {\n        delete value[symToStringTag];\n      }\n    }\n\n    return result;\n  }\n\n  var _getRawTag = getRawTag;\n  /** Used for built-in method references. */\n\n  var objectProto$1 = Object.prototype;\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n\n  var nativeObjectToString$1 = objectProto$1.toString;\n  /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */\n\n  function objectToString(value) {\n    return nativeObjectToString$1.call(value);\n  }\n\n  var _objectToString = objectToString;\n  /** `Object#toString` result references. */\n\n  var nullTag = '[object Null]',\n      undefinedTag = '[object Undefined]';\n  /** Built-in value references. */\n\n  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n  /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag;\n    }\n\n    return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);\n  }\n\n  var _baseGetTag = baseGetTag;\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n\n  function isObject(value) {\n    var type = _typeof(value);\n\n    return value != null && (type == 'object' || type == 'function');\n  }\n\n  var isObject_1 = isObject;\n  /** `Object#toString` result references. */\n\n  var asyncTag = '[object AsyncFunction]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      proxyTag = '[object Proxy]';\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n\n  function isFunction(value) {\n    if (!isObject_1(value)) {\n      return false;\n    } // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n\n\n    var tag = _baseGetTag(value);\n\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n  }\n\n  var isFunction_1 = isFunction;\n  /** Used to detect overreaching core-js shims. */\n\n  var coreJsData = _root['__core-js_shared__'];\n  var _coreJsData = coreJsData;\n  /** Used to detect methods masquerading as native. */\n\n  var maskSrcKey = function () {\n    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');\n    return uid ? 'Symbol(src)_1.' + uid : '';\n  }();\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n\n\n  function isMasked(func) {\n    return !!maskSrcKey && maskSrcKey in func;\n  }\n\n  var _isMasked = isMasked;\n  /** Used for built-in method references. */\n\n  var funcProto = Function.prototype;\n  /** Used to resolve the decompiled source of functions. */\n\n  var funcToString = funcProto.toString;\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to convert.\n   * @returns {string} Returns the source code.\n   */\n\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString.call(func);\n      } catch (e) {}\n\n      try {\n        return func + '';\n      } catch (e) {}\n    }\n\n    return '';\n  }\n\n  var _toSource = toSource;\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n  /** Used to detect host constructors (Safari). */\n\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n  /** Used for built-in method references. */\n\n  var funcProto$1 = Function.prototype,\n      objectProto$2 = Object.prototype;\n  /** Used to resolve the decompiled source of functions. */\n\n  var funcToString$1 = funcProto$1.toString;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n  /** Used to detect if a method is native. */\n\n  var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n\n  function baseIsNative(value) {\n    if (!isObject_1(value) || _isMasked(value)) {\n      return false;\n    }\n\n    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(_toSource(value));\n  }\n\n  var _baseIsNative = baseIsNative;\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  var _getValue = getValue;\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n\n  function getNative(object, key) {\n    var value = _getValue(object, key);\n\n    return _baseIsNative(value) ? value : undefined;\n  }\n\n  var _getNative = getNative;\n  /* Built-in method references that are verified to be native. */\n\n  var Map = _getNative(_root, 'Map');\n\n  var _Map = Map;\n  /* Built-in method references that are verified to be native. */\n\n  var nativeCreate = _getNative(Object, 'create');\n\n  var _nativeCreate = nativeCreate;\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n\n  function hashClear() {\n    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};\n    this.size = 0;\n  }\n\n  var _hashClear = hashClear;\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n  function hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n\n  var _hashDelete = hashDelete;\n  /** Used to stand-in for `undefined` hash values. */\n\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n  /** Used for built-in method references. */\n\n  var objectProto$3 = Object.prototype;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n  function hashGet(key) {\n    var data = this.__data__;\n\n    if (_nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED ? undefined : result;\n    }\n\n    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;\n  }\n\n  var _hashGet = hashGet;\n  /** Used for built-in method references. */\n\n  var objectProto$4 = Object.prototype;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n  function hashHas(key) {\n    var data = this.__data__;\n    return _nativeCreate ? data[key] !== undefined : hasOwnProperty$3.call(data, key);\n  }\n\n  var _hashHas = hashHas;\n  /** Used to stand-in for `undefined` hash values. */\n\n  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n\n  function hashSet(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = _nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;\n    return this;\n  }\n\n  var _hashSet = hashSet;\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function Hash(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  } // Add methods to `Hash`.\n\n\n  Hash.prototype.clear = _hashClear;\n  Hash.prototype['delete'] = _hashDelete;\n  Hash.prototype.get = _hashGet;\n  Hash.prototype.has = _hashHas;\n  Hash.prototype.set = _hashSet;\n  var _Hash = Hash;\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n\n  function mapCacheClear() {\n    this.size = 0;\n    this.__data__ = {\n      'hash': new _Hash(),\n      'map': new (_Map || _ListCache)(),\n      'string': new _Hash()\n    };\n  }\n\n  var _mapCacheClear = mapCacheClear;\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n\n  function isKeyable(value) {\n    var type = _typeof(value);\n\n    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n  }\n\n  var _isKeyable = isKeyable;\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return _isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n  }\n\n  var _getMapData = getMapData;\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n  function mapCacheDelete(key) {\n    var result = _getMapData(this, key)['delete'](key);\n\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n\n  var _mapCacheDelete = mapCacheDelete;\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n  function mapCacheGet(key) {\n    return _getMapData(this, key).get(key);\n  }\n\n  var _mapCacheGet = mapCacheGet;\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n  function mapCacheHas(key) {\n    return _getMapData(this, key).has(key);\n  }\n\n  var _mapCacheHas = mapCacheHas;\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n\n  function mapCacheSet(key, value) {\n    var data = _getMapData(this, key),\n        size = data.size;\n\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n  }\n\n  var _mapCacheSet = mapCacheSet;\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function MapCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  } // Add methods to `MapCache`.\n\n\n  MapCache.prototype.clear = _mapCacheClear;\n  MapCache.prototype['delete'] = _mapCacheDelete;\n  MapCache.prototype.get = _mapCacheGet;\n  MapCache.prototype.has = _mapCacheHas;\n  MapCache.prototype.set = _mapCacheSet;\n  var _MapCache = MapCache;\n  /** Used as the size to enable large array optimizations. */\n\n  var LARGE_ARRAY_SIZE = 200;\n  /**\n   * Sets the stack `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Stack\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the stack cache instance.\n   */\n\n  function stackSet(key, value) {\n    var data = this.__data__;\n\n    if (data instanceof _ListCache) {\n      var pairs = data.__data__;\n\n      if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\n        pairs.push([key, value]);\n        this.size = ++data.size;\n        return this;\n      }\n\n      data = this.__data__ = new _MapCache(pairs);\n    }\n\n    data.set(key, value);\n    this.size = data.size;\n    return this;\n  }\n\n  var _stackSet = stackSet;\n  /**\n   * Creates a stack cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function Stack(entries) {\n    var data = this.__data__ = new _ListCache(entries);\n    this.size = data.size;\n  } // Add methods to `Stack`.\n\n\n  Stack.prototype.clear = _stackClear;\n  Stack.prototype['delete'] = _stackDelete;\n  Stack.prototype.get = _stackGet;\n  Stack.prototype.has = _stackHas;\n  Stack.prototype.set = _stackSet;\n  var _Stack = Stack;\n\n  var defineProperty = function () {\n    try {\n      var func = _getNative(Object, 'defineProperty');\n\n      func({}, '', {});\n      return func;\n    } catch (e) {}\n  }();\n\n  var _defineProperty = defineProperty;\n  /**\n   * The base implementation of `assignValue` and `assignMergeValue` without\n   * value checks.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n\n  function baseAssignValue(object, key, value) {\n    if (key == '__proto__' && _defineProperty) {\n      _defineProperty(object, key, {\n        'configurable': true,\n        'enumerable': true,\n        'value': value,\n        'writable': true\n      });\n    } else {\n      object[key] = value;\n    }\n  }\n\n  var _baseAssignValue = baseAssignValue;\n  /**\n   * This function is like `assignValue` except that it doesn't assign\n   * `undefined` values.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n\n  function assignMergeValue(object, key, value) {\n    if (value !== undefined && !eq_1(object[key], value) || value === undefined && !(key in object)) {\n      _baseAssignValue(object, key, value);\n    }\n  }\n\n  var _assignMergeValue = assignMergeValue;\n  /**\n   * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n   *\n   * @private\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n\n  function createBaseFor(fromRight) {\n    return function (object, iteratee, keysFunc) {\n      var index = -1,\n          iterable = Object(object),\n          props = keysFunc(object),\n          length = props.length;\n\n      while (length--) {\n        var key = props[fromRight ? length : ++index];\n\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break;\n        }\n      }\n\n      return object;\n    };\n  }\n\n  var _createBaseFor = createBaseFor;\n  /**\n   * The base implementation of `baseForOwn` which iterates over `object`\n   * properties returned by `keysFunc` and invokes `iteratee` for each property.\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @returns {Object} Returns `object`.\n   */\n\n  var baseFor = _createBaseFor();\n\n  var _baseFor = baseFor;\n\n  var _cloneBuffer = createCommonjsModule(function (module, exports) {\n    /** Detect free variable `exports`. */\n    var freeExports = exports && !exports.nodeType && exports;\n    /** Detect free variable `module`. */\n\n    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */\n\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Built-in value references. */\n\n    var Buffer = moduleExports ? _root.Buffer : undefined,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n      buffer.copy(result);\n      return result;\n    }\n\n    module.exports = cloneBuffer;\n  });\n  /** Built-in value references. */\n\n\n  var Uint8Array = _root.Uint8Array;\n  var _Uint8Array = Uint8Array;\n  /**\n   * Creates a clone of `arrayBuffer`.\n   *\n   * @private\n   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n   * @returns {ArrayBuffer} Returns the cloned array buffer.\n   */\n\n  function cloneArrayBuffer(arrayBuffer) {\n    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));\n    return result;\n  }\n\n  var _cloneArrayBuffer = cloneArrayBuffer;\n  /**\n   * Creates a clone of `typedArray`.\n   *\n   * @private\n   * @param {Object} typedArray The typed array to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned typed array.\n   */\n\n  function cloneTypedArray(typedArray, isDeep) {\n    var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n  }\n\n  var _cloneTypedArray = cloneTypedArray;\n  /**\n   * Copies the values of `source` to `array`.\n   *\n   * @private\n   * @param {Array} source The array to copy values from.\n   * @param {Array} [array=[]] The array to copy values to.\n   * @returns {Array} Returns `array`.\n   */\n\n  function copyArray(source, array) {\n    var index = -1,\n        length = source.length;\n    array || (array = Array(length));\n\n    while (++index < length) {\n      array[index] = source[index];\n    }\n\n    return array;\n  }\n\n  var _copyArray = copyArray;\n  /** Built-in value references. */\n\n  var objectCreate = Object.create;\n  /**\n   * The base implementation of `_.create` without support for assigning\n   * properties to the created object.\n   *\n   * @private\n   * @param {Object} proto The object to inherit from.\n   * @returns {Object} Returns the new object.\n   */\n\n  var baseCreate = function () {\n    function object() {}\n\n    return function (proto) {\n      if (!isObject_1(proto)) {\n        return {};\n      }\n\n      if (objectCreate) {\n        return objectCreate(proto);\n      }\n\n      object.prototype = proto;\n      var result = new object();\n      object.prototype = undefined;\n      return result;\n    };\n  }();\n\n  var _baseCreate = baseCreate;\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n\n  function overArg(func, transform) {\n    return function (arg) {\n      return func(transform(arg));\n    };\n  }\n\n  var _overArg = overArg;\n  /** Built-in value references. */\n\n  var getPrototype = _overArg(Object.getPrototypeOf, Object);\n\n  var _getPrototype = getPrototype;\n  /** Used for built-in method references. */\n\n  var objectProto$5 = Object.prototype;\n  /**\n   * Checks if `value` is likely a prototype object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n   */\n\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$5;\n    return value === proto;\n  }\n\n  var _isPrototype = isPrototype;\n  /**\n   * Initializes an object clone.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n\n  function initCloneObject(object) {\n    return typeof object.constructor == 'function' && !_isPrototype(object) ? _baseCreate(_getPrototype(object)) : {};\n  }\n\n  var _initCloneObject = initCloneObject;\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n\n  function isObjectLike(value) {\n    return value != null && _typeof(value) == 'object';\n  }\n\n  var isObjectLike_1 = isObjectLike;\n  /** `Object#toString` result references. */\n\n  var argsTag = '[object Arguments]';\n  /**\n   * The base implementation of `_.isArguments`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   */\n\n  function baseIsArguments(value) {\n    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;\n  }\n\n  var _baseIsArguments = baseIsArguments;\n  /** Used for built-in method references. */\n\n  var objectProto$6 = Object.prototype;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;\n  /** Built-in value references. */\n\n  var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;\n  /**\n   * Checks if `value` is likely an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArguments(function() { return arguments; }());\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n\n  var isArguments = _baseIsArguments(function () {\n    return arguments;\n  }()) ? _baseIsArguments : function (value) {\n    return isObjectLike_1(value) && hasOwnProperty$4.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n  };\n  var isArguments_1 = isArguments;\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n\n  var isArray = Array.isArray;\n  var isArray_1 = isArray;\n  /** Used as references for various `Number` constants. */\n\n  var MAX_SAFE_INTEGER = 9007199254740991;\n  /**\n   * Checks if `value` is a valid array-like length.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n   * @example\n   *\n   * _.isLength(3);\n   * // => true\n   *\n   * _.isLength(Number.MIN_VALUE);\n   * // => false\n   *\n   * _.isLength(Infinity);\n   * // => false\n   *\n   * _.isLength('3');\n   * // => false\n   */\n\n  function isLength(value) {\n    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n  }\n\n  var isLength_1 = isLength;\n  /**\n   * Checks if `value` is array-like. A value is considered array-like if it's\n   * not a function and has a `value.length` that's an integer greater than or\n   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n   * @example\n   *\n   * _.isArrayLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLike(document.body.children);\n   * // => true\n   *\n   * _.isArrayLike('abc');\n   * // => true\n   *\n   * _.isArrayLike(_.noop);\n   * // => false\n   */\n\n  function isArrayLike(value) {\n    return value != null && isLength_1(value.length) && !isFunction_1(value);\n  }\n\n  var isArrayLike_1 = isArrayLike;\n  /**\n   * This method is like `_.isArrayLike` except that it also checks if `value`\n   * is an object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array-like object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArrayLikeObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLikeObject(document.body.children);\n   * // => true\n   *\n   * _.isArrayLikeObject('abc');\n   * // => false\n   *\n   * _.isArrayLikeObject(_.noop);\n   * // => false\n   */\n\n  function isArrayLikeObject(value) {\n    return isObjectLike_1(value) && isArrayLike_1(value);\n  }\n\n  var isArrayLikeObject_1 = isArrayLikeObject;\n  /**\n   * This method returns `false`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {boolean} Returns `false`.\n   * @example\n   *\n   * _.times(2, _.stubFalse);\n   * // => [false, false]\n   */\n\n  function stubFalse() {\n    return false;\n  }\n\n  var stubFalse_1 = stubFalse;\n  var isBuffer_1 = createCommonjsModule(function (module, exports) {\n    /** Detect free variable `exports`. */\n    var freeExports = exports && !exports.nodeType && exports;\n    /** Detect free variable `module`. */\n\n    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */\n\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Built-in value references. */\n\n    var Buffer = moduleExports ? _root.Buffer : undefined;\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n\n    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n\n    var isBuffer = nativeIsBuffer || stubFalse_1;\n    module.exports = isBuffer;\n  });\n  /** `Object#toString` result references. */\n\n  var objectTag = '[object Object]';\n  /** Used for built-in method references. */\n\n  var funcProto$2 = Function.prototype,\n      objectProto$7 = Object.prototype;\n  /** Used to resolve the decompiled source of functions. */\n\n  var funcToString$2 = funcProto$2.toString;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;\n  /** Used to infer the `Object` constructor. */\n\n  var objectCtorString = funcToString$2.call(Object);\n  /**\n   * Checks if `value` is a plain object, that is, an object created by the\n   * `Object` constructor or one with a `[[Prototype]]` of `null`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.8.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   * }\n   *\n   * _.isPlainObject(new Foo);\n   * // => false\n   *\n   * _.isPlainObject([1, 2, 3]);\n   * // => false\n   *\n   * _.isPlainObject({ 'x': 0, 'y': 0 });\n   * // => true\n   *\n   * _.isPlainObject(Object.create(null));\n   * // => true\n   */\n\n  function isPlainObject(value) {\n    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag) {\n      return false;\n    }\n\n    var proto = _getPrototype(value);\n\n    if (proto === null) {\n      return true;\n    }\n\n    var Ctor = hasOwnProperty$5.call(proto, 'constructor') && proto.constructor;\n    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;\n  }\n\n  var isPlainObject_1 = isPlainObject;\n  /** `Object#toString` result references. */\n\n  var argsTag$1 = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag$1 = '[object Function]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      objectTag$1 = '[object Object]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      weakMapTag = '[object WeakMap]';\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n  /** Used to identify `toStringTag` values of typed arrays. */\n\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n  /**\n   * The base implementation of `_.isTypedArray` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   */\n\n  function baseIsTypedArray(value) {\n    return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];\n  }\n\n  var _baseIsTypedArray = baseIsTypedArray;\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n\n  function baseUnary(func) {\n    return function (value) {\n      return func(value);\n    };\n  }\n\n  var _baseUnary = baseUnary;\n\n  var _nodeUtil = createCommonjsModule(function (module, exports) {\n    /** Detect free variable `exports`. */\n    var freeExports = exports && !exports.nodeType && exports;\n    /** Detect free variable `module`. */\n\n    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */\n\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Detect free variable `process` from Node.js. */\n\n    var freeProcess = moduleExports && _freeGlobal.process;\n    /** Used to access faster Node.js helpers. */\n\n    var nodeUtil = function () {\n      try {\n        // Use `util.types` for Node.js 10+.\n        var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n        if (types) {\n          return types;\n        } // Legacy `process.binding('util')` for Node.js < 10.\n\n\n        return freeProcess && freeProcess.binding && freeProcess.binding('util');\n      } catch (e) {}\n    }();\n\n    module.exports = nodeUtil;\n  });\n  /* Node.js helper references. */\n\n\n  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;\n  /**\n   * Checks if `value` is classified as a typed array.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   * @example\n   *\n   * _.isTypedArray(new Uint8Array);\n   * // => true\n   *\n   * _.isTypedArray([]);\n   * // => false\n   */\n\n  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;\n  var isTypedArray_1 = isTypedArray;\n  /**\n   * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n\n  function safeGet(object, key) {\n    if (key === 'constructor' && typeof object[key] === 'function') {\n      return;\n    }\n\n    if (key == '__proto__') {\n      return;\n    }\n\n    return object[key];\n  }\n\n  var _safeGet = safeGet;\n  /** Used for built-in method references. */\n\n  var objectProto$8 = Object.prototype;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;\n  /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n\n  function assignValue(object, key, value) {\n    var objValue = object[key];\n\n    if (!(hasOwnProperty$6.call(object, key) && eq_1(objValue, value)) || value === undefined && !(key in object)) {\n      _baseAssignValue(object, key, value);\n    }\n  }\n\n  var _assignValue = assignValue;\n  /**\n   * Copies properties of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy properties from.\n   * @param {Array} props The property identifiers to copy.\n   * @param {Object} [object={}] The object to copy properties to.\n   * @param {Function} [customizer] The function to customize copied values.\n   * @returns {Object} Returns `object`.\n   */\n\n  function copyObject(source, props, object, customizer) {\n    var isNew = !object;\n    object || (object = {});\n    var index = -1,\n        length = props.length;\n\n    while (++index < length) {\n      var key = props[index];\n      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;\n\n      if (newValue === undefined) {\n        newValue = source[key];\n      }\n\n      if (isNew) {\n        _baseAssignValue(object, key, newValue);\n      } else {\n        _assignValue(object, key, newValue);\n      }\n    }\n\n    return object;\n  }\n\n  var _copyObject = copyObject;\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n\n    return result;\n  }\n\n  var _baseTimes = baseTimes;\n  /** Used as references for various `Number` constants. */\n\n  var MAX_SAFE_INTEGER$1 = 9007199254740991;\n  /** Used to detect unsigned integer values. */\n\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n\n  function isIndex(value, length) {\n    var type = _typeof(value);\n\n    length = length == null ? MAX_SAFE_INTEGER$1 : length;\n    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n  }\n\n  var _isIndex = isIndex;\n  /** Used for built-in method references. */\n\n  var objectProto$9 = Object.prototype;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;\n  /**\n   * Creates an array of the enumerable property names of the array-like `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @param {boolean} inherited Specify returning inherited property names.\n   * @returns {Array} Returns the array of property names.\n   */\n\n  function arrayLikeKeys(value, inherited) {\n    var isArr = isArray_1(value),\n        isArg = !isArr && isArguments_1(value),\n        isBuff = !isArr && !isArg && isBuffer_1(value),\n        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),\n        skipIndexes = isArr || isArg || isBuff || isType,\n        result = skipIndexes ? _baseTimes(value.length, String) : [],\n        length = result.length;\n\n    for (var key in value) {\n      if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.\n      key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.\n      isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.\n      _isIndex(key, length)))) {\n        result.push(key);\n      }\n    }\n\n    return result;\n  }\n\n  var _arrayLikeKeys = arrayLikeKeys;\n  /**\n   * This function is like\n   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * except that it includes inherited enumerable properties.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n\n  function nativeKeysIn(object) {\n    var result = [];\n\n    if (object != null) {\n      for (var key in Object(object)) {\n        result.push(key);\n      }\n    }\n\n    return result;\n  }\n\n  var _nativeKeysIn = nativeKeysIn;\n  /** Used for built-in method references. */\n\n  var objectProto$a = Object.prototype;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;\n  /**\n   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n\n  function baseKeysIn(object) {\n    if (!isObject_1(object)) {\n      return _nativeKeysIn(object);\n    }\n\n    var isProto = _isPrototype(object),\n        result = [];\n\n    for (var key in object) {\n      if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {\n        result.push(key);\n      }\n    }\n\n    return result;\n  }\n\n  var _baseKeysIn = baseKeysIn;\n  /**\n   * Creates an array of the own and inherited enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keysIn(new Foo);\n   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n   */\n\n  function keysIn(object) {\n    return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);\n  }\n\n  var keysIn_1 = keysIn;\n  /**\n   * Converts `value` to a plain object flattening inherited enumerable string\n   * keyed properties of `value` to own properties of the plain object.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {Object} Returns the converted plain object.\n   * @example\n   *\n   * function Foo() {\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.assign({ 'a': 1 }, new Foo);\n   * // => { 'a': 1, 'b': 2 }\n   *\n   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n   * // => { 'a': 1, 'b': 2, 'c': 3 }\n   */\n\n  function toPlainObject(value) {\n    return _copyObject(value, keysIn_1(value));\n  }\n\n  var toPlainObject_1 = toPlainObject;\n  /**\n   * A specialized version of `baseMerge` for arrays and objects which performs\n   * deep merges and tracks traversed objects enabling objects with circular\n   * references to be merged.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @param {string} key The key of the value to merge.\n   * @param {number} srcIndex The index of `source`.\n   * @param {Function} mergeFunc The function to merge values.\n   * @param {Function} [customizer] The function to customize assigned values.\n   * @param {Object} [stack] Tracks traversed source values and their merged\n   *  counterparts.\n   */\n\n  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n    var objValue = _safeGet(object, key),\n        srcValue = _safeGet(source, key),\n        stacked = stack.get(srcValue);\n\n    if (stacked) {\n      _assignMergeValue(object, key, stacked);\n\n      return;\n    }\n\n    var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;\n    var isCommon = newValue === undefined;\n\n    if (isCommon) {\n      var isArr = isArray_1(srcValue),\n          isBuff = !isArr && isBuffer_1(srcValue),\n          isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);\n      newValue = srcValue;\n\n      if (isArr || isBuff || isTyped) {\n        if (isArray_1(objValue)) {\n          newValue = objValue;\n        } else if (isArrayLikeObject_1(objValue)) {\n          newValue = _copyArray(objValue);\n        } else if (isBuff) {\n          isCommon = false;\n          newValue = _cloneBuffer(srcValue, true);\n        } else if (isTyped) {\n          isCommon = false;\n          newValue = _cloneTypedArray(srcValue, true);\n        } else {\n          newValue = [];\n        }\n      } else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {\n        newValue = objValue;\n\n        if (isArguments_1(objValue)) {\n          newValue = toPlainObject_1(objValue);\n        } else if (!isObject_1(objValue) || isFunction_1(objValue)) {\n          newValue = _initCloneObject(srcValue);\n        }\n      } else {\n        isCommon = false;\n      }\n    }\n\n    if (isCommon) {\n      // Recursively merge objects and arrays (susceptible to call stack limits).\n      stack.set(srcValue, newValue);\n      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n      stack['delete'](srcValue);\n    }\n\n    _assignMergeValue(object, key, newValue);\n  }\n\n  var _baseMergeDeep = baseMergeDeep;\n  /**\n   * The base implementation of `_.merge` without support for multiple sources.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @param {number} srcIndex The index of `source`.\n   * @param {Function} [customizer] The function to customize merged values.\n   * @param {Object} [stack] Tracks traversed source values and their merged\n   *  counterparts.\n   */\n\n  function baseMerge(object, source, srcIndex, customizer, stack) {\n    if (object === source) {\n      return;\n    }\n\n    _baseFor(source, function (srcValue, key) {\n      stack || (stack = new _Stack());\n\n      if (isObject_1(srcValue)) {\n        _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n      } else {\n        var newValue = customizer ? customizer(_safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;\n\n        if (newValue === undefined) {\n          newValue = srcValue;\n        }\n\n        _assignMergeValue(object, key, newValue);\n      }\n    }, keysIn_1);\n  }\n\n  var _baseMerge = baseMerge;\n  /**\n   * This method returns the first argument it receives.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Util\n   * @param {*} value Any value.\n   * @returns {*} Returns `value`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   *\n   * console.log(_.identity(object) === object);\n   * // => true\n   */\n\n  function identity(value) {\n    return value;\n  }\n\n  var identity_1 = identity;\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0:\n        return func.call(thisArg);\n\n      case 1:\n        return func.call(thisArg, args[0]);\n\n      case 2:\n        return func.call(thisArg, args[0], args[1]);\n\n      case 3:\n        return func.call(thisArg, args[0], args[1], args[2]);\n    }\n\n    return func.apply(thisArg, args);\n  }\n\n  var _apply = apply;\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n\n  var nativeMax = Math.max;\n  /**\n   * A specialized version of `baseRest` which transforms the rest array.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @param {Function} transform The rest array transform.\n   * @returns {Function} Returns the new function.\n   */\n\n  function overRest(func, start, transform) {\n    start = nativeMax(start === undefined ? func.length - 1 : start, 0);\n    return function () {\n      var args = arguments,\n          index = -1,\n          length = nativeMax(args.length - start, 0),\n          array = Array(length);\n\n      while (++index < length) {\n        array[index] = args[start + index];\n      }\n\n      index = -1;\n      var otherArgs = Array(start + 1);\n\n      while (++index < start) {\n        otherArgs[index] = args[index];\n      }\n\n      otherArgs[start] = transform(array);\n      return _apply(func, this, otherArgs);\n    };\n  }\n\n  var _overRest = overRest;\n  /**\n   * Creates a function that returns `value`.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {*} value The value to return from the new function.\n   * @returns {Function} Returns the new constant function.\n   * @example\n   *\n   * var objects = _.times(2, _.constant({ 'a': 1 }));\n   *\n   * console.log(objects);\n   * // => [{ 'a': 1 }, { 'a': 1 }]\n   *\n   * console.log(objects[0] === objects[1]);\n   * // => true\n   */\n\n  function constant(value) {\n    return function () {\n      return value;\n    };\n  }\n\n  var constant_1 = constant;\n  /**\n   * The base implementation of `setToString` without support for hot loop shorting.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n\n  var baseSetToString = !_defineProperty ? identity_1 : function (func, string) {\n    return _defineProperty(func, 'toString', {\n      'configurable': true,\n      'enumerable': false,\n      'value': constant_1(string),\n      'writable': true\n    });\n  };\n  var _baseSetToString = baseSetToString;\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n\n  var nativeNow = Date.now;\n  /**\n   * Creates a function that'll short out and invoke `identity` instead\n   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n   * milliseconds.\n   *\n   * @private\n   * @param {Function} func The function to restrict.\n   * @returns {Function} Returns the new shortable function.\n   */\n\n  function shortOut(func) {\n    var count = 0,\n        lastCalled = 0;\n    return function () {\n      var stamp = nativeNow(),\n          remaining = HOT_SPAN - (stamp - lastCalled);\n      lastCalled = stamp;\n\n      if (remaining > 0) {\n        if (++count >= HOT_COUNT) {\n          return arguments[0];\n        }\n      } else {\n        count = 0;\n      }\n\n      return func.apply(undefined, arguments);\n    };\n  }\n\n  var _shortOut = shortOut;\n  /**\n   * Sets the `toString` method of `func` to return `string`.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n\n  var setToString = _shortOut(_baseSetToString);\n\n  var _setToString = setToString;\n  /**\n   * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @returns {Function} Returns the new function.\n   */\n\n  function baseRest(func, start) {\n    return _setToString(_overRest(func, start, identity_1), func + '');\n  }\n\n  var _baseRest = baseRest;\n  /**\n   * Checks if the given arguments are from an iteratee call.\n   *\n   * @private\n   * @param {*} value The potential iteratee value argument.\n   * @param {*} index The potential iteratee index or key argument.\n   * @param {*} object The potential iteratee object argument.\n   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n   *  else `false`.\n   */\n\n  function isIterateeCall(value, index, object) {\n    if (!isObject_1(object)) {\n      return false;\n    }\n\n    var type = _typeof(index);\n\n    if (type == 'number' ? isArrayLike_1(object) && _isIndex(index, object.length) : type == 'string' && index in object) {\n      return eq_1(object[index], value);\n    }\n\n    return false;\n  }\n\n  var _isIterateeCall = isIterateeCall;\n  /**\n   * Creates a function like `_.assign`.\n   *\n   * @private\n   * @param {Function} assigner The function to assign values.\n   * @returns {Function} Returns the new assigner function.\n   */\n\n  function createAssigner(assigner) {\n    return _baseRest(function (object, sources) {\n      var index = -1,\n          length = sources.length,\n          customizer = length > 1 ? sources[length - 1] : undefined,\n          guard = length > 2 ? sources[2] : undefined;\n      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;\n\n      if (guard && _isIterateeCall(sources[0], sources[1], guard)) {\n        customizer = length < 3 ? undefined : customizer;\n        length = 1;\n      }\n\n      object = Object(object);\n\n      while (++index < length) {\n        var source = sources[index];\n\n        if (source) {\n          assigner(object, source, index, customizer);\n        }\n      }\n\n      return object;\n    });\n  }\n\n  var _createAssigner = createAssigner;\n  /**\n   * This method is like `_.assign` except that it recursively merges own and\n   * inherited enumerable string keyed properties of source objects into the\n   * destination object. Source properties that resolve to `undefined` are\n   * skipped if a destination value exists. Array and plain object properties\n   * are merged recursively. Other objects and value types are overridden by\n   * assignment. Source objects are applied from left to right. Subsequent\n   * sources overwrite property assignments of previous sources.\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.5.0\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} [sources] The source objects.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * var object = {\n   *   'a': [{ 'b': 2 }, { 'd': 4 }]\n   * };\n   *\n   * var other = {\n   *   'a': [{ 'c': 3 }, { 'e': 5 }]\n   * };\n   *\n   * _.merge(object, other);\n   * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n   */\n\n  var merge = _createAssigner(function (object, source, srcIndex) {\n    _baseMerge(object, source, srcIndex);\n  });\n\n  var merge_1 = merge;\n  /**\r\n   * The base plugin class\r\n   * - When you do `handsfree.use()` it actually extends this class\r\n   */\n\n  var Plugin = /*#__PURE__*/function () {\n    function Plugin(plugin, handsfree) {\n      var _this23 = this;\n\n      _classCallCheck(this, Plugin);\n\n      var _handsfree$config, _handsfree$config$plu; // Props\n\n\n      this.plugin = plugin;\n      this.handsfree = handsfree; // Copy properties and methods from plugin into class\n\n      Object.keys(plugin).forEach(function (prop) {\n        _this23[prop] = plugin[prop];\n      }); // handsfree.config.plugin[name] overwrites plugin.config\n\n      var handsfreePluginConfig = (_handsfree$config = handsfree.config) === null || _handsfree$config === void 0 ? void 0 : (_handsfree$config$plu = _handsfree$config.plugin) === null || _handsfree$config$plu === void 0 ? void 0 : _handsfree$config$plu[plugin.name];\n\n      if (typeof handsfreePluginConfig === 'boolean') {\n        handsfreePluginConfig = {\n          enabled: handsfreePluginConfig\n        };\n      } // Disable plugins via new Handsfree(config)\n\n\n      if (_typeof(handsfreePluginConfig) === 'object') {\n        merge_1(this.config, handsfreePluginConfig);\n\n        if (typeof handsfreePluginConfig.enabled === 'boolean') {\n          this.enabled = handsfreePluginConfig.enabled;\n        }\n      }\n    }\n    /**\r\n     * Toggle plugins\r\n     */\n\n\n    _createClass(Plugin, [{\n      key: \"enable\",\n      value: function enable() {\n        !this.enabled && this.onEnable && this.onEnable(this.handsfree);\n        this.enabled = true;\n      }\n    }, {\n      key: \"disable\",\n      value: function disable() {\n        this.enabled && this.onDisable && this.onDisable(this.handsfree);\n        this.enabled = false;\n      }\n    }]);\n\n    return Plugin;\n  }();\n  /**\r\n   * The base gesture class\r\n   * - When you do `handsfree.useGesture()` it actually extends this class\r\n   */\n\n\n  var BaseGesture = /*#__PURE__*/function () {\n    function BaseGesture(gesture, handsfree) {\n      var _this24 = this;\n\n      _classCallCheck(this, BaseGesture);\n\n      var _handsfree$config, _handsfree$config$ges; // Props\n\n\n      this.handsfree = handsfree; // Copy properties and methods from plugin into class\n\n      Object.keys(gesture).forEach(function (prop) {\n        _this24[prop] = gesture[prop];\n      }); // handsfree.config.gesture[name] overwrites gesture.config\n\n      var handsfreeGestureConfig = (_handsfree$config = handsfree.config) === null || _handsfree$config === void 0 ? void 0 : (_handsfree$config$ges = _handsfree$config.gesture) === null || _handsfree$config$ges === void 0 ? void 0 : _handsfree$config$ges[gesture.name];\n\n      if (typeof handsfreeGestureConfig === 'boolean') {\n        handsfreeGestureConfig = {\n          enabled: handsfreeGestureConfig\n        };\n      } // Disable gestures via new Handsfree(config)\n\n\n      if (_typeof(handsfreeGestureConfig) === 'object') {\n        merge_1(this.config, handsfreeGestureConfig);\n\n        if (typeof handsfreeGestureConfig.enabled === 'boolean') {\n          this.enabled = handsfreeGestureConfig.enabled;\n        }\n      }\n    }\n    /**\r\n     * Toggle gesture\r\n     */\n\n\n    _createClass(BaseGesture, [{\n      key: \"enable\",\n      value: function enable() {\n        this.enabled = true;\n        this.updateGestureEstimator();\n      }\n    }, {\n      key: \"disable\",\n      value: function disable() {\n        this.enabled = false;\n        this.updateGestureEstimator();\n      }\n      /**\r\n       * Update the estimator when a gesture is toggled\r\n       */\n\n    }, {\n      key: \"updateGestureEstimator\",\n      value: function updateGestureEstimator() {\n        var _this25 = this;\n\n        this.models.forEach(function (name) {\n          _this25.handsfree.model[name].updateGestureEstimator();\n        });\n      }\n    }]);\n\n    return BaseGesture;\n  }();\n\n  var GestureFingerpose = /*#__PURE__*/function (_BaseGesture) {\n    _inherits(GestureFingerpose, _BaseGesture);\n\n    var _super6 = _createSuper(GestureFingerpose);\n\n    function GestureFingerpose(handsfree, config) {\n      var _this26;\n\n      _classCallCheck(this, GestureFingerpose);\n\n      _this26 = _super6.call(this, handsfree, config);\n      _this26.algorithm = 'fingerpose'; // Contains the fingerpose GestureDescription\n\n      _this26.compiledDescription = null;\n      return _this26;\n    }\n\n    return _createClass(GestureFingerpose);\n  }(BaseGesture);\n  /**\r\n   * The following are all the defaults\r\n   * \r\n   * @see https://handsfree.js.org/ref/prop/config\r\n   */\n\n\n  var defaultConfig = {\n    // Whether to automatically start or not\n    // This works both during instantiation or with .update()\n    autostart: false,\n    // Use CDN by default\n    assetsPath: 'https://unpkg.com/handsfree@8.5.1/build/lib/assets',\n    // This will load everything but the models. This is useful when you want to use run inference\n    // on another device or context but run the plugins on the current device\n    isClient: false,\n    // Gesture config\n    gesture: {},\n    // Setup config. Ignore this to have everything done for you automatically\n    setup: {\n      // The canvas element to use for rendering debug info like skeletons and keypoints\n      canvas: {\n        weboji: {\n          // The canvas element to hold the skeletons and keypoints for weboji model\n          $el: null,\n          width: 1280,\n          height: 720\n        },\n        hands: {\n          // The canvas element to hold the skeletons and keypoints for hand model\n          $el: null,\n          width: 1280,\n          height: 720\n        },\n        handpose: {\n          // The canvas element to hold the skeletons and keypoints for hand model\n          $el: null,\n          width: 1280,\n          height: 720\n        },\n        pose: {\n          // The canvas element to hold the skeletons and keypoints for pose model\n          $el: null,\n          width: 1280,\n          height: 720\n        },\n        facemesh: {\n          // The canvas element to hold the skeletons and keypoints for facemesh model\n          $el: null,\n          width: 1280,\n          height: 720\n        }\n      },\n      // The video source to use. \n      // - If not present one will be created and use the webcam\n      // - If present without a source then the webcam will be used\n      // - If present with a source then that source will be used instead of the webcam\n      video: {\n        // The video element to hold the webcam stream\n        $el: null,\n        width: 1280,\n        height: 720\n      },\n      // The wrapping element\n      wrap: {\n        // The element to put the video and canvas inside of\n        $el: null,\n        // The parent element\n        $parent: null\n      }\n    },\n    // Weboji model\n    weboji: {\n      enabled: false,\n      throttle: 0,\n      videoSettings: {\n        // The video, canvas, or image element\n        // Omit this to auto create a <VIDEO> with the webcam\n        videoElement: null,\n        // ID of the device to use\n        // Omit this to use the system default\n        deviceId: null,\n        // Which camera to use on the device\n        // Possible values: 'user' (front), 'environment' (back)\n        facingMode: 'user',\n        // Video dimensions\n        idealWidth: 320,\n        idealHeight: 240,\n        minWidth: 240,\n        maxWidth: 1280,\n        minHeight: 240,\n        maxHeight: 1280\n      },\n      // Thresholds needed before these are considered \"activated\"\n      // - Ranges from 0 (not active) to 1 (fully active)\n      morphs: {\n        threshold: {\n          smileRight: 0.7,\n          smileLeft: 0.7,\n          browLeftDown: 0.8,\n          browRightDown: 0.8,\n          browLeftUp: 0.8,\n          browRightUp: 0.8,\n          eyeLeftClosed: 0.4,\n          eyeRightClosed: 0.4,\n          mouthOpen: 0.3,\n          mouthRound: 0.8,\n          upperLip: 0.5\n        }\n      }\n    },\n    // Hands model\n    hands: {\n      enabled: false,\n      // The maximum number of hands to detect [0 - 4]\n      maxNumHands: 2,\n      // Minimum confidence [0 - 1] for a hand to be considered detected\n      minDetectionConfidence: 0.5,\n      // Minimum confidence [0 - 1] for the landmark tracker to be considered detected\n      // Higher values are more robust at the expense of higher latency\n      minTrackingConfidence: 0.5\n    },\n    // Facemesh model\n    facemesh: {\n      enabled: false,\n      // The maximum number of faces to detect [1 - 4]\n      maxNumFaces: 1,\n      // Minimum confidence [0 - 1] for a face to be considered detected\n      minDetectionConfidence: 0.5,\n      // Minimum confidence [0 - 1] for the landmark tracker to be considered detected\n      // Higher values are more robust at the expense of higher latency\n      minTrackingConfidence: 0.5\n    },\n    // Pose model\n    pose: {\n      enabled: false,\n      // Outputs only the top 25 pose landmarks if true,\n      // otherwise shows all 33 full body pose landmarks\n      // - Note: Setting this to true may result in better accuracy \n      upperBodyOnly: false,\n      // Helps reduce jitter over multiple frames if true\n      smoothLandmarks: true,\n      // Minimum confidence [0 - 1] for a person detection to be considered detected\n      minDetectionConfidence: 0.5,\n      // Minimum confidence [0 - 1] for the pose tracker to be considered detected\n      // Higher values are more robust at the expense of higher latency\n      minTrackingConfidence: 0.5\n    },\n    handpose: {\n      enabled: false,\n      // The backend to use: 'webgl' or 'wasm'\n      //  Currently only webgl is supported\n      backend: 'webgl',\n      // How many frames to go without running the bounding box detector. \n      // Set to a lower value if you want a safety net in case the mesh detector produces consistently flawed predictions.\n      maxContinuousChecks: Infinity,\n      // Threshold for discarding a prediction\n      detectionConfidence: 0.8,\n      // A float representing the threshold for deciding whether boxes overlap too much in non-maximum suppression. Must be between [0, 1]\n      iouThreshold: 0.3,\n      // A threshold for deciding when to remove boxes based on score in non-maximum suppression.\n      scoreThreshold: 0.75\n    },\n    plugin: {}\n  };\n  /**\n   * Gets the timestamp of the number of milliseconds that have elapsed since\n   * the Unix epoch (1 January 1970 00:00:00 UTC).\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Date\n   * @returns {number} Returns the timestamp.\n   * @example\n   *\n   * _.defer(function(stamp) {\n   *   console.log(_.now() - stamp);\n   * }, _.now());\n   * // => Logs the number of milliseconds it took for the deferred invocation.\n   */\n\n  var now = function now() {\n    return _root.Date.now();\n  };\n\n  var now_1 = now;\n  /** `Object#toString` result references. */\n\n  var symbolTag = '[object Symbol]';\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n\n  function isSymbol(value) {\n    return _typeof(value) == 'symbol' || isObjectLike_1(value) && _baseGetTag(value) == symbolTag;\n  }\n\n  var isSymbol_1 = isSymbol;\n  /** Used as references for various `Number` constants. */\n\n  var NAN = 0 / 0;\n  /** Used to match leading and trailing whitespace. */\n\n  var reTrim = /^\\s+|\\s+$/g;\n  /** Used to detect bad signed hexadecimal string values. */\n\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n  /** Used to detect binary string values. */\n\n  var reIsBinary = /^0b[01]+$/i;\n  /** Used to detect octal string values. */\n\n  var reIsOctal = /^0o[0-7]+$/i;\n  /** Built-in method references without a dependency on `root`. */\n\n  var freeParseInt = parseInt;\n  /**\n   * Converts `value` to a number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   * @example\n   *\n   * _.toNumber(3.2);\n   * // => 3.2\n   *\n   * _.toNumber(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toNumber(Infinity);\n   * // => Infinity\n   *\n   * _.toNumber('3.2');\n   * // => 3.2\n   */\n\n  function toNumber(value) {\n    if (typeof value == 'number') {\n      return value;\n    }\n\n    if (isSymbol_1(value)) {\n      return NAN;\n    }\n\n    if (isObject_1(value)) {\n      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n      value = isObject_1(other) ? other + '' : other;\n    }\n\n    if (typeof value != 'string') {\n      return value === 0 ? value : +value;\n    }\n\n    value = value.replace(reTrim, '');\n    var isBinary = reIsBinary.test(value);\n    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n  }\n\n  var toNumber_1 = toNumber;\n  /** Error message constants. */\n\n  var FUNC_ERROR_TEXT = 'Expected a function';\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n\n  var nativeMax$1 = Math.max,\n      nativeMin = Math.min;\n  /**\n   * Creates a debounced function that delays invoking `func` until after `wait`\n   * milliseconds have elapsed since the last time the debounced function was\n   * invoked. The debounced function comes with a `cancel` method to cancel\n   * delayed `func` invocations and a `flush` method to immediately invoke them.\n   * Provide `options` to indicate whether `func` should be invoked on the\n   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n   * with the last arguments provided to the debounced function. Subsequent\n   * calls to the debounced function return the result of the last `func`\n   * invocation.\n   *\n   * **Note:** If `leading` and `trailing` options are `true`, `func` is\n   * invoked on the trailing edge of the timeout only if the debounced function\n   * is invoked more than once during the `wait` timeout.\n   *\n   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n   * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n   *\n   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n   * for details over the differences between `_.debounce` and `_.throttle`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to debounce.\n   * @param {number} [wait=0] The number of milliseconds to delay.\n   * @param {Object} [options={}] The options object.\n   * @param {boolean} [options.leading=false]\n   *  Specify invoking on the leading edge of the timeout.\n   * @param {number} [options.maxWait]\n   *  The maximum time `func` is allowed to be delayed before it's invoked.\n   * @param {boolean} [options.trailing=true]\n   *  Specify invoking on the trailing edge of the timeout.\n   * @returns {Function} Returns the new debounced function.\n   * @example\n   *\n   * // Avoid costly calculations while the window size is in flux.\n   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n   *\n   * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n   * jQuery(element).on('click', _.debounce(sendMail, 300, {\n   *   'leading': true,\n   *   'trailing': false\n   * }));\n   *\n   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n   * var source = new EventSource('/stream');\n   * jQuery(source).on('message', debounced);\n   *\n   * // Cancel the trailing debounced invocation.\n   * jQuery(window).on('popstate', debounced.cancel);\n   */\n\n  function debounce(func, wait, options) {\n    var lastArgs,\n        lastThis,\n        maxWait,\n        result,\n        timerId,\n        lastCallTime,\n        lastInvokeTime = 0,\n        leading = false,\n        maxing = false,\n        trailing = true;\n\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n\n    wait = toNumber_1(wait) || 0;\n\n    if (isObject_1(options)) {\n      leading = !!options.leading;\n      maxing = 'maxWait' in options;\n      maxWait = maxing ? nativeMax$1(toNumber_1(options.maxWait) || 0, wait) : maxWait;\n      trailing = 'trailing' in options ? !!options.trailing : trailing;\n    }\n\n    function invokeFunc(time) {\n      var args = lastArgs,\n          thisArg = lastThis;\n      lastArgs = lastThis = undefined;\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args);\n      return result;\n    }\n\n    function leadingEdge(time) {\n      // Reset any `maxWait` timer.\n      lastInvokeTime = time; // Start the timer for the trailing edge.\n\n      timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n      return leading ? invokeFunc(time) : result;\n    }\n\n    function remainingWait(time) {\n      var timeSinceLastCall = time - lastCallTime,\n          timeSinceLastInvoke = time - lastInvokeTime,\n          timeWaiting = wait - timeSinceLastCall;\n      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n    }\n\n    function shouldInvoke(time) {\n      var timeSinceLastCall = time - lastCallTime,\n          timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n      // trailing edge, the system time has gone backwards and we're treating\n      // it as the trailing edge, or we've hit the `maxWait` limit.\n\n      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n    }\n\n    function timerExpired() {\n      var time = now_1();\n\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      } // Restart the timer.\n\n\n      timerId = setTimeout(timerExpired, remainingWait(time));\n    }\n\n    function trailingEdge(time) {\n      timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n      // debounced at least once.\n\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    function cancel() {\n      if (timerId !== undefined) {\n        clearTimeout(timerId);\n      }\n\n      lastInvokeTime = 0;\n      lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n\n    function flush() {\n      return timerId === undefined ? result : trailingEdge(now_1());\n    }\n\n    function debounced() {\n      var time = now_1(),\n          isInvoking = shouldInvoke(time);\n      lastArgs = arguments;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n\n        if (maxing) {\n          // Handle invocations in a tight loop.\n          clearTimeout(timerId);\n          timerId = setTimeout(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n\n      if (timerId === undefined) {\n        timerId = setTimeout(timerExpired, wait);\n      }\n\n      return result;\n    }\n\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n  }\n\n  var debounce_1 = debounce;\n  /** Error message constants. */\n\n  var FUNC_ERROR_TEXT$1 = 'Expected a function';\n  /**\n   * Creates a throttled function that only invokes `func` at most once per\n   * every `wait` milliseconds. The throttled function comes with a `cancel`\n   * method to cancel delayed `func` invocations and a `flush` method to\n   * immediately invoke them. Provide `options` to indicate whether `func`\n   * should be invoked on the leading and/or trailing edge of the `wait`\n   * timeout. The `func` is invoked with the last arguments provided to the\n   * throttled function. Subsequent calls to the throttled function return the\n   * result of the last `func` invocation.\n   *\n   * **Note:** If `leading` and `trailing` options are `true`, `func` is\n   * invoked on the trailing edge of the timeout only if the throttled function\n   * is invoked more than once during the `wait` timeout.\n   *\n   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n   * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n   *\n   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n   * for details over the differences between `_.throttle` and `_.debounce`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to throttle.\n   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n   * @param {Object} [options={}] The options object.\n   * @param {boolean} [options.leading=true]\n   *  Specify invoking on the leading edge of the timeout.\n   * @param {boolean} [options.trailing=true]\n   *  Specify invoking on the trailing edge of the timeout.\n   * @returns {Function} Returns the new throttled function.\n   * @example\n   *\n   * // Avoid excessively updating the position while scrolling.\n   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n   *\n   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n   * jQuery(element).on('click', throttled);\n   *\n   * // Cancel the trailing throttled invocation.\n   * jQuery(window).on('popstate', throttled.cancel);\n   */\n\n  function throttle(func, wait, options) {\n    var leading = true,\n        trailing = true;\n\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT$1);\n    }\n\n    if (isObject_1(options)) {\n      leading = 'leading' in options ? !!options.leading : leading;\n      trailing = 'trailing' in options ? !!options.trailing : trailing;\n    }\n\n    return debounce_1(func, wait, {\n      'leading': leading,\n      'maxWait': wait,\n      'trailing': trailing\n    });\n  }\n\n  var throttle_1 = throttle;\n  /*!\n   * VERSION: 2.1.3\n   * DATE: 2019-05-17\n   * UPDATES AND DOCS AT: http://greensock.com\n   *\n   * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.\n   * This work is subject to the terms at http://greensock.com/standard-license or for\n   * Club GreenSock members, the software agreement that was issued with your membership.\n   *\n   * @author: Jack Doyle, jack@greensock.com\n   */\n\n  /* eslint-disable */\n\n  /* ES6 changes:\n  \t- declare and export _gsScope at top.\n  \t- set var TweenLite = the result of the main function\n  \t- export default TweenLite at the bottom\n  \t- return TweenLite at the bottom of the main function\n  \t- pass in _gsScope as the first parameter of the main function (which is actually at the bottom)\n  \t- remove the \"export to multiple environments\" in Definition().\n   */\n\n  var _gsScope = typeof window !== \"undefined\" ? window : typeof module !== \"undefined\" && module.exports && typeof global !== \"undefined\" ? global : window || {};\n\n  var TweenLite = function (window) {\n    var _exports = {},\n        _doc = window.document,\n        _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;\n\n    if (_globals.TweenLite) {\n      return _globals.TweenLite; //in case the core set of classes is already loaded, don't instantiate twice.\n    }\n\n    var _namespace = function _namespace(ns) {\n      var a = ns.split(\".\"),\n          p = _globals,\n          i;\n\n      for (i = 0; i < a.length; i++) {\n        p[a[i]] = p = p[a[i]] || {};\n      }\n\n      return p;\n    },\n        gs = _namespace(\"com.greensock\"),\n        _tinyNum = 0.00000001,\n        _slice = function _slice(a) {\n      //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()\n      var b = [],\n          l = a.length,\n          i;\n\n      for (i = 0; i !== l; b.push(a[i++])) {}\n\n      return b;\n    },\n        _emptyFunc = function _emptyFunc() {},\n        _isArray = function () {\n      //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, \"(obj instanceof Array)\" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)\n      var toString = Object.prototype.toString,\n          array = toString.call([]);\n      return function (obj) {\n        return obj != null && (obj instanceof Array || _typeof(obj) === \"object\" && !!obj.push && toString.call(obj) === array);\n      };\n    }(),\n        a,\n        i,\n        p,\n        _ticker,\n        _tickerActive,\n        _defLookup = {},\n\n    /**\n     * @constructor\n     * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.\n     * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is\n     * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin\n     * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.\n     *\n     * Every definition will be added to a \"com.greensock\" global object (typically window, but if a window.GreenSockGlobals object is found,\n     * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,\n     * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so\n     * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything\n     * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock\n     * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could\n     * sandbox the banner one like:\n     *\n     * <script>\n     *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a \"gs\" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, \"gs\" or \"banner\" or whatever.\n     * </script>\n     * <script src=\"js/greensock/v1.7/TweenMax.js\"></script>\n     * <script>\n     *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)\n     * </script>\n     * <script src=\"js/greensock/v1.6/TweenMax.js\"></script>\n     * <script>\n     *     gs.TweenLite.to(...); //would use v1.7\n     *     TweenLite.to(...); //would use v1.6\n     * </script>\n     *\n     * @param {!string} ns The namespace of the class definition, leaving off \"com.greensock.\" as that's assumed. For example, \"TweenLite\" or \"plugins.CSSPlugin\" or \"easing.Back\".\n     * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus \"com.greensock.\" prefix). For example [\"TweenLite\",\"plugins.TweenPlugin\",\"core.Animation\"]\n     * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.\n     * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)\n     */\n    Definition = function Definition(ns, dependencies, func, global) {\n      this.sc = _defLookup[ns] ? _defLookup[ns].sc : []; //subclasses\n\n      _defLookup[ns] = this;\n      this.gsClass = null;\n      this.func = func;\n      var _classes = [];\n\n      this.check = function (init) {\n        var i = dependencies.length,\n            missing = i,\n            cur,\n            a,\n            n,\n            cl;\n\n        while (--i > -1) {\n          if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {\n            _classes[i] = cur.gsClass;\n            missing--;\n          } else if (init) {\n            cur.sc.push(this);\n          }\n        }\n\n        if (missing === 0 && func) {\n          a = (\"com.greensock.\" + ns).split(\".\");\n          n = a.pop();\n          cl = _namespace(a.join(\".\"))[n] = this.gsClass = func.apply(func, _classes); //exports to multiple environments\n\n          if (global) {\n            _globals[n] = _exports[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)\n\n            /*\n            if (typeof(module) !== \"undefined\" && module.exports) { //node\n            \tif (ns === moduleName) {\n            \t\tmodule.exports = _exports[moduleName] = cl;\n            \t\tfor (i in _exports) {\n            \t\t\tcl[i] = _exports[i];\n            \t\t}\n            \t} else if (_exports[moduleName]) {\n            \t\t_exports[moduleName][n] = cl;\n            \t}\n            } else if (typeof(define) === \"function\" && define.amd){ //AMD\n            \tdefine((window.GreenSockAMDPath ? window.GreenSockAMDPath + \"/\" : \"\") + ns.split(\".\").pop(), [], function() { return cl; });\n            }\n            */\n          }\n\n          for (i = 0; i < this.sc.length; i++) {\n            this.sc[i].check();\n          }\n        }\n      };\n\n      this.check(true);\n    },\n        //used to create Definition instances (which basically registers a class that has dependencies).\n    _gsDefine = window._gsDefine = function (ns, dependencies, func, global) {\n      return new Definition(ns, dependencies, func, global);\n    },\n        //a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).\n    _class = gs._class = function (ns, func, global) {\n      func = func || function () {};\n\n      _gsDefine(ns, [], function () {\n        return func;\n      }, global);\n\n      return func;\n    };\n\n    _gsDefine.globals = _globals;\n    /*\n     * ----------------------------------------------------------------\n     * Ease\n     * ----------------------------------------------------------------\n     */\n\n    var _baseParams = [0, 0, 1, 1],\n        Ease = _class(\"easing.Ease\", function (func, extraParams, type, power) {\n      this._func = func;\n      this._type = type || 0;\n      this._power = power || 0;\n      this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;\n    }, true),\n        _easeMap = Ease.map = {},\n        _easeReg = Ease.register = function (ease, names, types, create) {\n      var na = names.split(\",\"),\n          i = na.length,\n          ta = (types || \"easeIn,easeOut,easeInOut\").split(\",\"),\n          e,\n          name,\n          j,\n          type;\n\n      while (--i > -1) {\n        name = na[i];\n        e = create ? _class(\"easing.\" + name, null, true) : gs.easing[name] || {};\n        j = ta.length;\n\n        while (--j > -1) {\n          type = ta[j];\n          _easeMap[name + \".\" + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();\n        }\n      }\n    };\n\n    p = Ease.prototype;\n    p._calcEnd = false;\n\n    p.getRatio = function (p) {\n      if (this._func) {\n        this._params[0] = p;\n        return this._func.apply(null, this._params);\n      }\n\n      var t = this._type,\n          pw = this._power,\n          r = t === 1 ? 1 - p : t === 2 ? p : p < 0.5 ? p * 2 : (1 - p) * 2;\n\n      if (pw === 1) {\n        r *= r;\n      } else if (pw === 2) {\n        r *= r * r;\n      } else if (pw === 3) {\n        r *= r * r * r;\n      } else if (pw === 4) {\n        r *= r * r * r * r;\n      }\n\n      return t === 1 ? 1 - r : t === 2 ? r : p < 0.5 ? r / 2 : 1 - r / 2;\n    }; //create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)\n\n\n    a = [\"Linear\", \"Quad\", \"Cubic\", \"Quart\", \"Quint,Strong\"];\n    i = a.length;\n\n    while (--i > -1) {\n      p = a[i] + \",Power\" + i;\n\n      _easeReg(new Ease(null, null, 1, i), p, \"easeOut\", true);\n\n      _easeReg(new Ease(null, null, 2, i), p, \"easeIn\" + (i === 0 ? \",easeNone\" : \"\"));\n\n      _easeReg(new Ease(null, null, 3, i), p, \"easeInOut\");\n    }\n\n    _easeMap.linear = gs.easing.Linear.easeIn;\n    _easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks\n\n    /*\n     * ----------------------------------------------------------------\n     * EventDispatcher\n     * ----------------------------------------------------------------\n     */\n\n    var EventDispatcher = _class(\"events.EventDispatcher\", function (target) {\n      this._listeners = {};\n      this._eventTarget = target || this;\n    });\n\n    p = EventDispatcher.prototype;\n\n    p.addEventListener = function (type, callback, scope, useParam, priority) {\n      priority = priority || 0;\n      var list = this._listeners[type],\n          index = 0,\n          listener,\n          i;\n\n      if (this === _ticker && !_tickerActive) {\n        _ticker.wake();\n      }\n\n      if (list == null) {\n        this._listeners[type] = list = [];\n      }\n\n      i = list.length;\n\n      while (--i > -1) {\n        listener = list[i];\n\n        if (listener.c === callback && listener.s === scope) {\n          list.splice(i, 1);\n        } else if (index === 0 && listener.pr < priority) {\n          index = i + 1;\n        }\n      }\n\n      list.splice(index, 0, {\n        c: callback,\n        s: scope,\n        up: useParam,\n        pr: priority\n      });\n    };\n\n    p.removeEventListener = function (type, callback) {\n      var list = this._listeners[type],\n          i;\n\n      if (list) {\n        i = list.length;\n\n        while (--i > -1) {\n          if (list[i].c === callback) {\n            list.splice(i, 1);\n            return;\n          }\n        }\n      }\n    };\n\n    p.dispatchEvent = function (type) {\n      var list = this._listeners[type],\n          i,\n          t,\n          listener;\n\n      if (list) {\n        i = list.length;\n\n        if (i > 1) {\n          list = list.slice(0); //in case addEventListener() is called from within a listener/callback (otherwise the index could change, resulting in a skip)\n        }\n\n        t = this._eventTarget;\n\n        while (--i > -1) {\n          listener = list[i];\n\n          if (listener) {\n            if (listener.up) {\n              listener.c.call(listener.s || t, {\n                type: type,\n                target: t\n              });\n            } else {\n              listener.c.call(listener.s || t);\n            }\n          }\n        }\n      }\n    };\n    /*\n     * ----------------------------------------------------------------\n     * Ticker\n     * ----------------------------------------------------------------\n     */\n\n\n    var _reqAnimFrame = window.requestAnimationFrame,\n        _cancelAnimFrame = window.cancelAnimationFrame,\n        _getTime = Date.now || function () {\n      return new Date().getTime();\n    },\n        _lastUpdate = _getTime(); //now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.\n\n\n    a = [\"ms\", \"moz\", \"webkit\", \"o\"];\n    i = a.length;\n\n    while (--i > -1 && !_reqAnimFrame) {\n      _reqAnimFrame = window[a[i] + \"RequestAnimationFrame\"];\n      _cancelAnimFrame = window[a[i] + \"CancelAnimationFrame\"] || window[a[i] + \"CancelRequestAnimationFrame\"];\n    }\n\n    _class(\"Ticker\", function (fps, useRAF) {\n      var _self = this,\n          _startTime = _getTime(),\n          _useRAF = useRAF !== false && _reqAnimFrame ? \"auto\" : false,\n          _lagThreshold = 500,\n          _adjustedLag = 33,\n          _tickWord = \"tick\",\n          //helps reduce gc burden\n      _fps,\n          _req,\n          _id,\n          _gap,\n          _nextTime,\n          _tick = function _tick(manual) {\n        var elapsed = _getTime() - _lastUpdate,\n            overlap,\n            dispatch;\n\n        if (elapsed > _lagThreshold) {\n          _startTime += elapsed - _adjustedLag;\n        }\n\n        _lastUpdate += elapsed;\n        _self.time = (_lastUpdate - _startTime) / 1000;\n        overlap = _self.time - _nextTime;\n\n        if (!_fps || overlap > 0 || manual === true) {\n          _self.frame++;\n          _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);\n          dispatch = true;\n        }\n\n        if (manual !== true) {\n          //make sure the request is made before we dispatch the \"tick\" event so that timing is maintained. Otherwise, if processing the \"tick\" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.\n          _id = _req(_tick);\n        }\n\n        if (dispatch) {\n          _self.dispatchEvent(_tickWord);\n        }\n      };\n\n      EventDispatcher.call(_self);\n      _self.time = _self.frame = 0;\n\n      _self.tick = function () {\n        _tick(true);\n      };\n\n      _self.lagSmoothing = function (threshold, adjustedLag) {\n        if (!arguments.length) {\n          //if lagSmoothing() is called with no arguments, treat it like a getter that returns a boolean indicating if it's enabled or not. This is purposely undocumented and is for internal use.\n          return _lagThreshold < 1 / _tinyNum;\n        }\n\n        _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited\n\n        _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);\n      };\n\n      _self.sleep = function () {\n        if (_id == null) {\n          return;\n        }\n\n        if (!_useRAF || !_cancelAnimFrame) {\n          clearTimeout(_id);\n        } else {\n          _cancelAnimFrame(_id);\n        }\n\n        _req = _emptyFunc;\n        _id = null;\n\n        if (_self === _ticker) {\n          _tickerActive = false;\n        }\n      };\n\n      _self.wake = function (seamless) {\n        if (_id !== null) {\n          _self.sleep();\n        } else if (seamless) {\n          _startTime += -_lastUpdate + (_lastUpdate = _getTime());\n        } else if (_self.frame > 10) {\n          //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().\n          _lastUpdate = _getTime() - _lagThreshold + 5;\n        }\n\n        _req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {\n          return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);\n        } : _reqAnimFrame;\n\n        if (_self === _ticker) {\n          _tickerActive = true;\n        }\n\n        _tick(2);\n      };\n\n      _self.fps = function (value) {\n        if (!arguments.length) {\n          return _fps;\n        }\n\n        _fps = value;\n        _gap = 1 / (_fps || 60);\n        _nextTime = this.time + _gap;\n\n        _self.wake();\n      };\n\n      _self.useRAF = function (value) {\n        if (!arguments.length) {\n          return _useRAF;\n        }\n\n        _self.sleep();\n\n        _useRAF = value;\n\n        _self.fps(_fps);\n      };\n\n      _self.fps(fps); //a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.\n\n\n      setTimeout(function () {\n        if (_useRAF === \"auto\" && _self.frame < 5 && (_doc || {}).visibilityState !== \"hidden\") {\n          _self.useRAF(false);\n        }\n      }, 1500);\n    });\n\n    p = gs.Ticker.prototype = new gs.events.EventDispatcher();\n    p.constructor = gs.Ticker;\n    /*\n     * ----------------------------------------------------------------\n     * Animation\n     * ----------------------------------------------------------------\n     */\n\n    var Animation = _class(\"core.Animation\", function (duration, vars) {\n      this.vars = vars = vars || {};\n      this._duration = this._totalDuration = duration || 0;\n      this._delay = Number(vars.delay) || 0;\n      this._timeScale = 1;\n      this._active = !!vars.immediateRender;\n      this.data = vars.data;\n      this._reversed = !!vars.reversed;\n\n      if (!_rootTimeline) {\n        return;\n      }\n\n      if (!_tickerActive) {\n        //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.\n        _ticker.wake();\n      }\n\n      var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;\n      tl.add(this, tl._time);\n\n      if (this.vars.paused) {\n        this.paused(true);\n      }\n    });\n\n    _ticker = Animation.ticker = new gs.Ticker();\n    p = Animation.prototype;\n    p._dirty = p._gc = p._initted = p._paused = false;\n    p._totalTime = p._time = 0;\n    p._rawPrevTime = -1;\n    p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;\n    p._paused = false; //some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.\n\n    var _checkTimeout = function _checkTimeout() {\n      if (_tickerActive && _getTime() - _lastUpdate > 2000 && ((_doc || {}).visibilityState !== \"hidden\" || !_ticker.lagSmoothing())) {\n        //note: if the tab is hidden, we should still wake if lagSmoothing has been disabled.\n        _ticker.wake();\n      }\n\n      var t = setTimeout(_checkTimeout, 2000);\n\n      if (t.unref) {\n        // allows a node process to exit even if the timeouts callback hasn't been invoked. Without it, the node process could hang as this function is called every two seconds.\n        t.unref();\n      }\n    };\n\n    _checkTimeout();\n\n    p.play = function (from, suppressEvents) {\n      if (from != null) {\n        this.seek(from, suppressEvents);\n      }\n\n      return this.reversed(false).paused(false);\n    };\n\n    p.pause = function (atTime, suppressEvents) {\n      if (atTime != null) {\n        this.seek(atTime, suppressEvents);\n      }\n\n      return this.paused(true);\n    };\n\n    p.resume = function (from, suppressEvents) {\n      if (from != null) {\n        this.seek(from, suppressEvents);\n      }\n\n      return this.paused(false);\n    };\n\n    p.seek = function (time, suppressEvents) {\n      return this.totalTime(Number(time), suppressEvents !== false);\n    };\n\n    p.restart = function (includeDelay, suppressEvents) {\n      return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true);\n    };\n\n    p.reverse = function (from, suppressEvents) {\n      if (from != null) {\n        this.seek(from || this.totalDuration(), suppressEvents);\n      }\n\n      return this.reversed(true).paused(false);\n    };\n\n    p.render = function (time, suppressEvents, force) {//stub - we override this method in subclasses.\n    };\n\n    p.invalidate = function () {\n      this._time = this._totalTime = 0;\n      this._initted = this._gc = false;\n      this._rawPrevTime = -1;\n\n      if (this._gc || !this.timeline) {\n        this._enabled(true);\n      }\n\n      return this;\n    };\n\n    p.isActive = function () {\n      var tl = this._timeline,\n          //the 2 root timelines won't have a _timeline; they're always active.\n      startTime = this._startTime,\n          rawTime;\n      return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale - _tinyNum;\n    };\n\n    p._enabled = function (enabled, ignoreTimeline) {\n      if (!_tickerActive) {\n        _ticker.wake();\n      }\n\n      this._gc = !enabled;\n      this._active = this.isActive();\n\n      if (ignoreTimeline !== true) {\n        if (enabled && !this.timeline) {\n          this._timeline.add(this, this._startTime - this._delay);\n        } else if (!enabled && this.timeline) {\n          this._timeline._remove(this, true);\n        }\n      }\n\n      return false;\n    };\n\n    p._kill = function (vars, target) {\n      return this._enabled(false, false);\n    };\n\n    p.kill = function (vars, target) {\n      this._kill(vars, target);\n\n      return this;\n    };\n\n    p._uncache = function (includeSelf) {\n      var tween = includeSelf ? this : this.timeline;\n\n      while (tween) {\n        tween._dirty = true;\n        tween = tween.timeline;\n      }\n\n      return this;\n    };\n\n    p._swapSelfInParams = function (params) {\n      var i = params.length,\n          copy = params.concat();\n\n      while (--i > -1) {\n        if (params[i] === \"{self}\") {\n          copy[i] = this;\n        }\n      }\n\n      return copy;\n    };\n\n    p._callback = function (type) {\n      var v = this.vars,\n          callback = v[type],\n          params = v[type + \"Params\"],\n          scope = v[type + \"Scope\"] || v.callbackScope || this,\n          l = params ? params.length : 0;\n\n      switch (l) {\n        //speed optimization; call() is faster than apply() so use it when there are only a few parameters (which is by far most common). Previously we simply did var v = this.vars; v[type].apply(v[type + \"Scope\"] || v.callbackScope || this, v[type + \"Params\"] || _blankArray);\n        case 0:\n          callback.call(scope);\n          break;\n\n        case 1:\n          callback.call(scope, params[0]);\n          break;\n\n        case 2:\n          callback.call(scope, params[0], params[1]);\n          break;\n\n        default:\n          callback.apply(scope, params);\n      }\n    }; //----Animation getters/setters --------------------------------------------------------\n\n\n    p.eventCallback = function (type, callback, params, scope) {\n      if ((type || \"\").substr(0, 2) === \"on\") {\n        var v = this.vars;\n\n        if (arguments.length === 1) {\n          return v[type];\n        }\n\n        if (callback == null) {\n          delete v[type];\n        } else {\n          v[type] = callback;\n          v[type + \"Params\"] = _isArray(params) && params.join(\"\").indexOf(\"{self}\") !== -1 ? this._swapSelfInParams(params) : params;\n          v[type + \"Scope\"] = scope;\n        }\n\n        if (type === \"onUpdate\") {\n          this._onUpdate = callback;\n        }\n      }\n\n      return this;\n    };\n\n    p.delay = function (value) {\n      if (!arguments.length) {\n        return this._delay;\n      }\n\n      if (this._timeline.smoothChildTiming) {\n        this.startTime(this._startTime + value - this._delay);\n      }\n\n      this._delay = value;\n      return this;\n    };\n\n    p.duration = function (value) {\n      if (!arguments.length) {\n        this._dirty = false;\n        return this._duration;\n      }\n\n      this._duration = this._totalDuration = value;\n\n      this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.\n\n\n      if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {\n        this.totalTime(this._totalTime * (value / this._duration), true);\n      }\n      return this;\n    };\n\n    p.totalDuration = function (value) {\n      this._dirty = false;\n      return !arguments.length ? this._totalDuration : this.duration(value);\n    };\n\n    p.time = function (value, suppressEvents) {\n      if (!arguments.length) {\n        return this._time;\n      }\n\n      if (this._dirty) {\n        this.totalDuration();\n      }\n\n      return this.totalTime(value > this._duration ? this._duration : value, suppressEvents);\n    };\n\n    p.totalTime = function (time, suppressEvents, uncapped) {\n      if (!_tickerActive) {\n        _ticker.wake();\n      }\n\n      if (!arguments.length) {\n        return this._totalTime;\n      }\n\n      if (this._timeline) {\n        if (time < 0 && !uncapped) {\n          time += this.totalDuration();\n        }\n\n        if (this._timeline.smoothChildTiming) {\n          if (this._dirty) {\n            this.totalDuration();\n          }\n\n          var totalDuration = this._totalDuration,\n              tl = this._timeline;\n\n          if (time > totalDuration && !uncapped) {\n            time = totalDuration;\n          }\n\n          this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;\n\n          if (!tl._dirty) {\n            //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.\n            this._uncache(false);\n          } //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.\n\n\n          if (tl._timeline) {\n            while (tl._timeline) {\n              if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {\n                tl.totalTime(tl._totalTime, true);\n              }\n\n              tl = tl._timeline;\n            }\n          }\n        }\n\n        if (this._gc) {\n          this._enabled(true, false);\n        }\n\n        if (this._totalTime !== time || this._duration === 0) {\n          if (_lazyTweens.length) {\n            _lazyRender();\n          }\n\n          this.render(time, suppressEvents, false);\n\n          if (_lazyTweens.length) {\n            //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.\n            _lazyRender();\n          }\n        }\n      }\n\n      return this;\n    };\n\n    p.progress = p.totalProgress = function (value, suppressEvents) {\n      var duration = this.duration();\n      return !arguments.length ? duration ? this._time / duration : this.ratio : this.totalTime(duration * value, suppressEvents);\n    };\n\n    p.startTime = function (value) {\n      if (!arguments.length) {\n        return this._startTime;\n      }\n\n      if (value !== this._startTime) {\n        this._startTime = value;\n        if (this.timeline) if (this.timeline._sortChildren) {\n          this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.\n        }\n      }\n\n      return this;\n    };\n\n    p.endTime = function (includeRepeats) {\n      return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale;\n    };\n\n    p.timeScale = function (value) {\n      if (!arguments.length) {\n        return this._timeScale;\n      }\n\n      var pauseTime, t;\n      value = value || _tinyNum; //can't allow zero because it'll throw the math off\n\n      if (this._timeline && this._timeline.smoothChildTiming) {\n        pauseTime = this._pauseTime;\n        t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();\n        this._startTime = t - (t - this._startTime) * this._timeScale / value;\n      }\n\n      this._timeScale = value;\n      t = this.timeline;\n\n      while (t && t.timeline) {\n        //must update the duration/totalDuration of all ancestor timelines immediately in case in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.\n        t._dirty = true;\n        t.totalDuration();\n        t = t.timeline;\n      }\n\n      return this;\n    };\n\n    p.reversed = function (value) {\n      if (!arguments.length) {\n        return this._reversed;\n      }\n\n      if (value != this._reversed) {\n        this._reversed = value;\n        this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true);\n      }\n\n      return this;\n    };\n\n    p.paused = function (value) {\n      if (!arguments.length) {\n        return this._paused;\n      }\n\n      var tl = this._timeline,\n          raw,\n          elapsed;\n      if (value != this._paused) if (tl) {\n        if (!_tickerActive && !value) {\n          _ticker.wake();\n        }\n\n        raw = tl.rawTime();\n        elapsed = raw - this._pauseTime;\n\n        if (!value && tl.smoothChildTiming) {\n          this._startTime += elapsed;\n\n          this._uncache(false);\n        }\n\n        this._pauseTime = value ? raw : null;\n        this._paused = value;\n        this._active = this.isActive();\n\n        if (!value && elapsed !== 0 && this._initted && this.duration()) {\n          raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;\n          this.render(raw, raw === this._totalTime, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.\n        }\n      }\n\n      if (this._gc && !value) {\n        this._enabled(true, false);\n      }\n\n      return this;\n    };\n    /*\n     * ----------------------------------------------------------------\n     * SimpleTimeline\n     * ----------------------------------------------------------------\n     */\n\n\n    var SimpleTimeline = _class(\"core.SimpleTimeline\", function (vars) {\n      Animation.call(this, 0, vars);\n      this.autoRemoveChildren = this.smoothChildTiming = true;\n    });\n\n    p = SimpleTimeline.prototype = new Animation();\n    p.constructor = SimpleTimeline;\n    p.kill()._gc = false;\n    p._first = p._last = p._recent = null;\n    p._sortChildren = false;\n\n    p.add = p.insert = function (child, position, align, stagger) {\n      var prevTween, st;\n      child._startTime = Number(position || 0) + child._delay;\n      if (child._paused) if (this !== child._timeline) {\n        //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).\n        child._pauseTime = this.rawTime() - (child._timeline.rawTime() - child._pauseTime);\n      }\n\n      if (child.timeline) {\n        child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.\n\n      }\n\n      child.timeline = child._timeline = this;\n\n      if (child._gc) {\n        child._enabled(true, true);\n      }\n\n      prevTween = this._last;\n\n      if (this._sortChildren) {\n        st = child._startTime;\n\n        while (prevTween && prevTween._startTime > st) {\n          prevTween = prevTween._prev;\n        }\n      }\n\n      if (prevTween) {\n        child._next = prevTween._next;\n        prevTween._next = child;\n      } else {\n        child._next = this._first;\n        this._first = child;\n      }\n\n      if (child._next) {\n        child._next._prev = child;\n      } else {\n        this._last = child;\n      }\n\n      child._prev = prevTween;\n      this._recent = child;\n\n      if (this._timeline) {\n        this._uncache(true);\n      }\n\n      return this;\n    };\n\n    p._remove = function (tween, skipDisable) {\n      if (tween.timeline === this) {\n        if (!skipDisable) {\n          tween._enabled(false, true);\n        }\n\n        if (tween._prev) {\n          tween._prev._next = tween._next;\n        } else if (this._first === tween) {\n          this._first = tween._next;\n        }\n\n        if (tween._next) {\n          tween._next._prev = tween._prev;\n        } else if (this._last === tween) {\n          this._last = tween._prev;\n        }\n\n        tween._next = tween._prev = tween.timeline = null;\n\n        if (tween === this._recent) {\n          this._recent = this._last;\n        }\n\n        if (this._timeline) {\n          this._uncache(true);\n        }\n      }\n\n      return this;\n    };\n\n    p.render = function (time, suppressEvents, force) {\n      var tween = this._first,\n          next;\n      this._totalTime = this._time = this._rawPrevTime = time;\n\n      while (tween) {\n        next = tween._next; //record it here because the value could change after rendering...\n\n        if (tween._active || time >= tween._startTime && !tween._paused && !tween._gc) {\n          if (!tween._reversed) {\n            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);\n          } else {\n            tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);\n          }\n        }\n\n        tween = next;\n      }\n    };\n\n    p.rawTime = function () {\n      if (!_tickerActive) {\n        _ticker.wake();\n      }\n\n      return this._totalTime;\n    };\n    /*\n     * ----------------------------------------------------------------\n     * TweenLite\n     * ----------------------------------------------------------------\n     */\n\n\n    var TweenLite = _class(\"TweenLite\", function (target, duration, vars) {\n      Animation.call(this, duration, vars);\n      this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this \"hot\" method)\n\n      if (target == null) {\n        throw \"Cannot tween a null target.\";\n      }\n\n      this.target = target = typeof target !== \"string\" ? target : TweenLite.selector(target) || target;\n      var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),\n          overwrite = this.vars.overwrite,\n          i,\n          targ,\n          targets;\n      this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === \"number\" ? overwrite >> 0 : _overwriteLookup[overwrite];\n\n      if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== \"number\") {\n        this._targets = targets = _slice(target); //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()\n\n        this._propLookup = [];\n        this._siblings = [];\n\n        for (i = 0; i < targets.length; i++) {\n          targ = targets[i];\n\n          if (!targ) {\n            targets.splice(i--, 1);\n            continue;\n          } else if (typeof targ === \"string\") {\n            targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings\n\n            if (typeof targ === \"string\") {\n              targets.splice(i + 1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)\n            }\n\n            continue;\n          } else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {\n            //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.\n            targets.splice(i--, 1);\n            this._targets = targets = targets.concat(_slice(targ));\n            continue;\n          }\n\n          this._siblings[i] = _register(targ, this, false);\n          if (overwrite === 1) if (this._siblings[i].length > 1) {\n            _applyOverwrite(targ, this, null, 1, this._siblings[i]);\n          }\n        }\n      } else {\n        this._propLookup = {};\n        this._siblings = _register(target, this, false);\n        if (overwrite === 1) if (this._siblings.length > 1) {\n          _applyOverwrite(target, this, null, 1, this._siblings);\n        }\n      }\n\n      if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {\n        this._time = -_tinyNum; //forces a render without having to set the render() \"force\" parameter to true because we want to allow lazying by default (using the \"force\" parameter always forces an immediate full render)\n\n        this.render(Math.min(0, -this._delay)); //in case delay is negative\n      }\n    }, true),\n        _isSelector = function _isSelector(v) {\n      return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType); //we cannot check \"nodeType\" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.\n    },\n        _autoCSS = function _autoCSS(vars, target) {\n      var css = {},\n          p;\n\n      for (p in vars) {\n        if (!_reservedProps[p] && (!(p in target) || p === \"transform\" || p === \"x\" || p === \"y\" || p === \"width\" || p === \"height\" || p === \"className\" || p === \"border\") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {\n          //note: <img> elements contain read-only \"x\" and \"y\" properties. We should also prioritize editing css width/height rather than the element's properties.\n          css[p] = vars[p];\n          delete vars[p];\n        }\n      }\n\n      vars.css = css;\n    };\n\n    p = TweenLite.prototype = new Animation();\n    p.constructor = TweenLite;\n    p.kill()._gc = false; //----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------\n\n    p.ratio = 0;\n    p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;\n    p._notifyPluginsOfEnabled = p._lazy = false;\n    TweenLite.version = \"2.1.3\";\n    TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);\n    TweenLite.defaultOverwrite = \"auto\";\n    TweenLite.ticker = _ticker;\n    TweenLite.autoSleep = 120;\n\n    TweenLite.lagSmoothing = function (threshold, adjustedLag) {\n      _ticker.lagSmoothing(threshold, adjustedLag);\n    };\n\n    TweenLite.selector = window.$ || window.jQuery || function (e) {\n      var selector = window.$ || window.jQuery;\n\n      if (selector) {\n        TweenLite.selector = selector;\n        return selector(e);\n      }\n\n      if (!_doc) {\n        //in some dev environments (like Angular 6), GSAP gets loaded before the document is defined! So re-query it here if/when necessary.\n        _doc = window.document;\n      }\n\n      return !_doc ? e : _doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById(e.charAt(0) === \"#\" ? e.substr(1) : e);\n    };\n\n    var _lazyTweens = [],\n        _lazyLookup = {},\n        _numbersExp = /(?:(-|-=|\\+=)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n        _relExp = /[\\+-]=-?[\\.\\d]/,\n        //_nonNumbersExp = /(?:([\\-+](?!(\\d|=)))|[^\\d\\-+=e]|(e(?![\\-+][\\d])))+/ig,\n    _setRatio = function _setRatio(v) {\n      var pt = this._firstPT,\n          min = 0.000001,\n          val;\n\n      while (pt) {\n        val = !pt.blob ? pt.c * v + pt.s : v === 1 && this.end != null ? this.end : v ? this.join(\"\") : this.start;\n\n        if (pt.m) {\n          val = pt.m.call(this._tween, val, this._target || pt.t, this._tween);\n        } else if (val < min) if (val > -min && !pt.blob) {\n          //prevents issues with converting very small numbers to strings in the browser\n          val = 0;\n        }\n\n        if (!pt.f) {\n          pt.t[pt.p] = val;\n        } else if (pt.fp) {\n          pt.t[pt.p](pt.fp, val);\n        } else {\n          pt.t[pt.p](val);\n        }\n\n        pt = pt._next;\n      }\n    },\n        _blobRound = function _blobRound(v) {\n      return (v * 1000 | 0) / 1000 + \"\";\n    },\n        //compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, \"rgb(0,0,0)\" and \"rgb(100,50,0)\" would become [\"rgb(\", 0, \",\", 50, \",0)\"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a \"start\" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join(\"\")).\n    _blobDif = function _blobDif(start, end, filter, pt) {\n      var a = [],\n          charIndex = 0,\n          s = \"\",\n          color = 0,\n          startNums,\n          endNums,\n          num,\n          i,\n          l,\n          nonNumbers,\n          currentNum;\n      a.start = start;\n      a.end = end;\n      start = a[0] = start + \"\"; //ensure values are strings\n\n      end = a[1] = end + \"\";\n\n      if (filter) {\n        filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.\n\n        start = a[0];\n        end = a[1];\n      }\n\n      a.length = 0;\n      startNums = start.match(_numbersExp) || [];\n      endNums = end.match(_numbersExp) || [];\n\n      if (pt) {\n        pt._next = null;\n        pt.blob = 1;\n        a._firstPT = a._applyPT = pt; //apply last in the linked list (which means inserting it first)\n      }\n\n      l = endNums.length;\n\n      for (i = 0; i < l; i++) {\n        currentNum = endNums[i];\n        nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);\n        s += nonNumbers || !i ? nonNumbers : \",\"; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n\n        charIndex += nonNumbers.length;\n\n        if (color) {\n          //sense rgba() values and round them.\n          color = (color + 1) % 5;\n        } else if (nonNumbers.substr(-5) === \"rgba(\") {\n          color = 1;\n        }\n\n        if (currentNum === startNums[i] || startNums.length <= i) {\n          s += currentNum;\n        } else {\n          if (s) {\n            a.push(s);\n            s = \"\";\n          }\n\n          num = parseFloat(startNums[i]);\n          a.push(num);\n          a._firstPT = {\n            _next: a._firstPT,\n            t: a,\n            p: a.length - 1,\n            s: num,\n            c: (currentNum.charAt(1) === \"=\" ? parseInt(currentNum.charAt(0) + \"1\", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0,\n            f: 0,\n            m: color && color < 4 ? Math.round : _blobRound\n          }; //limiting to 3 decimal places and casting as a string can really help performance when array.join() is called!\n          //note: we don't set _prev because we'll never need to remove individual PropTweens from this list.\n        }\n\n        charIndex += currentNum.length;\n      }\n\n      s += end.substr(charIndex);\n\n      if (s) {\n        a.push(s);\n      }\n\n      a.setRatio = _setRatio;\n\n      if (_relExp.test(end)) {\n        //if the end string contains relative values, delete it so that on the final render (in _setRatio()), we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n        a.end = null;\n      }\n\n      return a;\n    },\n        //note: \"funcParam\" is only necessary for function-based getters/setters that require an extra parameter like getAttribute(\"width\") and setAttribute(\"width\", value). In this example, funcParam would be \"width\". Used by AttrPlugin for example.\n    _addPropTween = function _addPropTween(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {\n      if (typeof end === \"function\") {\n        end = end(index || 0, target);\n      }\n\n      var type = _typeof(target[prop]),\n          getterName = type !== \"function\" ? \"\" : prop.indexOf(\"set\") || typeof target[\"get\" + prop.substr(3)] !== \"function\" ? prop : \"get\" + prop.substr(3),\n          s = start !== \"get\" ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),\n          isRelative = typeof end === \"string\" && end.charAt(1) === \"=\",\n          pt = {\n        t: target,\n        p: prop,\n        s: s,\n        f: type === \"function\",\n        pg: 0,\n        n: overwriteProp || prop,\n        m: !mod ? 0 : typeof mod === \"function\" ? mod : Math.round,\n        pr: 0,\n        c: isRelative ? parseInt(end.charAt(0) + \"1\", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0\n      },\n          blob;\n\n      if (typeof s !== \"number\" || typeof end !== \"number\" && !isRelative) {\n        if (funcParam || isNaN(s) || !isRelative && isNaN(end) || typeof s === \"boolean\" || typeof end === \"boolean\") {\n          //a blob (string that has multiple numbers in it)\n          pt.fp = funcParam;\n          blob = _blobDif(s, isRelative ? parseFloat(pt.s) + pt.c + (pt.s + \"\").replace(/[0-9\\-\\.]/g, \"\") : end, stringFilter || TweenLite.defaultStringFilter, pt);\n          pt = {\n            t: blob,\n            p: \"setRatio\",\n            s: 0,\n            c: 1,\n            f: 2,\n            pg: 0,\n            n: overwriteProp || prop,\n            pr: 0,\n            m: 0\n          }; //\"2\" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.\n        } else {\n          pt.s = parseFloat(s);\n\n          if (!isRelative) {\n            pt.c = parseFloat(end) - pt.s || 0;\n          }\n        }\n      }\n\n      if (pt.c) {\n        //only add it to the linked list if there's a change.\n        if (pt._next = this._firstPT) {\n          pt._next._prev = pt;\n        }\n\n        this._firstPT = pt;\n        return pt;\n      }\n    },\n        _internals = TweenLite._internals = {\n      isArray: _isArray,\n      isSelector: _isSelector,\n      lazyTweens: _lazyTweens,\n      blobDif: _blobDif\n    },\n        //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.\n    _plugins = TweenLite._plugins = {},\n        _tweenLookup = _internals.tweenLookup = {},\n        _tweenLookupNum = 0,\n        _reservedProps = _internals.reservedProps = {\n      ease: 1,\n      delay: 1,\n      overwrite: 1,\n      onComplete: 1,\n      onCompleteParams: 1,\n      onCompleteScope: 1,\n      useFrames: 1,\n      runBackwards: 1,\n      startAt: 1,\n      onUpdate: 1,\n      onUpdateParams: 1,\n      onUpdateScope: 1,\n      onStart: 1,\n      onStartParams: 1,\n      onStartScope: 1,\n      onReverseComplete: 1,\n      onReverseCompleteParams: 1,\n      onReverseCompleteScope: 1,\n      onRepeat: 1,\n      onRepeatParams: 1,\n      onRepeatScope: 1,\n      easeParams: 1,\n      yoyo: 1,\n      immediateRender: 1,\n      repeat: 1,\n      repeatDelay: 1,\n      data: 1,\n      paused: 1,\n      reversed: 1,\n      autoCSS: 1,\n      lazy: 1,\n      onOverwrite: 1,\n      callbackScope: 1,\n      stringFilter: 1,\n      id: 1,\n      yoyoEase: 1,\n      stagger: 1\n    },\n        _overwriteLookup = {\n      none: 0,\n      all: 1,\n      auto: 2,\n      concurrent: 3,\n      allOnStart: 4,\n      preexisting: 5,\n      \"true\": 1,\n      \"false\": 0\n    },\n        _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),\n        _rootTimeline = Animation._rootTimeline = new SimpleTimeline(),\n        _nextGCFrame = 30,\n        _lazyRender = _internals.lazyRender = function () {\n      var l = _lazyTweens.length,\n          i,\n          tween;\n      _lazyLookup = {};\n\n      for (i = 0; i < l; i++) {\n        tween = _lazyTweens[i];\n\n        if (tween && tween._lazy !== false) {\n          tween.render(tween._lazy[0], tween._lazy[1], true);\n          tween._lazy = false;\n        }\n      }\n\n      _lazyTweens.length = 0;\n    };\n\n    _rootTimeline._startTime = _ticker.time;\n    _rootFramesTimeline._startTime = _ticker.frame;\n    _rootTimeline._active = _rootFramesTimeline._active = true;\n    setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a \"tick\" before code runs which means any lazy renders wouldn't run before the next official \"tick\".\n\n    Animation._updateRoot = TweenLite.render = function () {\n      var i, a, p;\n\n      if (_lazyTweens.length) {\n        //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.\n        _lazyRender();\n      }\n\n      _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);\n\n      _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);\n\n      if (_lazyTweens.length) {\n        _lazyRender();\n      }\n\n      if (_ticker.frame >= _nextGCFrame) {\n        //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to\n        _nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);\n\n        for (p in _tweenLookup) {\n          a = _tweenLookup[p].tweens;\n          i = a.length;\n\n          while (--i > -1) {\n            if (a[i]._gc) {\n              a.splice(i, 1);\n            }\n          }\n\n          if (a.length === 0) {\n            delete _tweenLookup[p];\n          }\n        } //if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly\n\n\n        p = _rootTimeline._first;\n        if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {\n          while (p && p._paused) {\n            p = p._next;\n          }\n\n          if (!p) {\n            _ticker.sleep();\n          }\n        }\n      }\n    };\n\n    _ticker.addEventListener(\"tick\", Animation._updateRoot);\n\n    var _register = function _register(target, tween, scrub) {\n      var id = target._gsTweenID,\n          a,\n          i;\n\n      if (!_tweenLookup[id || (target._gsTweenID = id = \"t\" + _tweenLookupNum++)]) {\n        _tweenLookup[id] = {\n          target: target,\n          tweens: []\n        };\n      }\n\n      if (tween) {\n        a = _tweenLookup[id].tweens;\n        a[i = a.length] = tween;\n\n        if (scrub) {\n          while (--i > -1) {\n            if (a[i] === tween) {\n              a.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return _tweenLookup[id].tweens;\n    },\n        _onOverwrite = function _onOverwrite(overwrittenTween, overwritingTween, target, killedProps) {\n      var func = overwrittenTween.vars.onOverwrite,\n          r1,\n          r2;\n\n      if (func) {\n        r1 = func(overwrittenTween, overwritingTween, target, killedProps);\n      }\n\n      func = TweenLite.onOverwrite;\n\n      if (func) {\n        r2 = func(overwrittenTween, overwritingTween, target, killedProps);\n      }\n\n      return r1 !== false && r2 !== false;\n    },\n        _applyOverwrite = function _applyOverwrite(target, tween, props, mode, siblings) {\n      var i, changed, curTween, l;\n\n      if (mode === 1 || mode >= 4) {\n        l = siblings.length;\n\n        for (i = 0; i < l; i++) {\n          if ((curTween = siblings[i]) !== tween) {\n            if (!curTween._gc) {\n              if (curTween._kill(null, target, tween)) {\n                changed = true;\n              }\n            }\n          } else if (mode === 5) {\n            break;\n          }\n        }\n\n        return changed;\n      } //NOTE: Add tiny amount to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)\n\n\n      var startTime = tween._startTime + _tinyNum,\n          overlaps = [],\n          oCount = 0,\n          zeroDur = tween._duration === 0,\n          globalStart;\n      i = siblings.length;\n\n      while (--i > -1) {\n        if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) ;else if (curTween._timeline !== tween._timeline) {\n          globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);\n\n          if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {\n            overlaps[oCount++] = curTween;\n          }\n        } else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= _tinyNum * 2)) {\n          overlaps[oCount++] = curTween;\n        }\n      }\n\n      i = oCount;\n\n      while (--i > -1) {\n        curTween = overlaps[i];\n        l = curTween._firstPT; //we need to discern if there were property tweens originally; if they all get removed in the next line's _kill() call, the tween should be killed. See https://github.com/greensock/GreenSock-JS/issues/278\n\n        if (mode === 2) if (curTween._kill(props, target, tween)) {\n          changed = true;\n        }\n\n        if (mode !== 2 || !curTween._firstPT && curTween._initted && l) {\n          if (mode !== 2 && !_onOverwrite(curTween, tween)) {\n            continue;\n          }\n\n          if (curTween._enabled(false, false)) {\n            //if all property tweens have been overwritten, kill the tween.\n            changed = true;\n          }\n        }\n      }\n\n      return changed;\n    },\n        _checkOverlap = function _checkOverlap(tween, reference, zeroDur) {\n      var tl = tween._timeline,\n          ts = tl._timeScale,\n          t = tween._startTime;\n\n      while (tl._timeline) {\n        t += tl._startTime;\n        ts *= tl._timeScale;\n\n        if (tl._paused) {\n          return -100;\n        }\n\n        tl = tl._timeline;\n      }\n\n      t /= ts;\n      return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;\n    }; //---- TweenLite instance methods -----------------------------------------------------------------------------\n\n\n    p._init = function () {\n      var v = this.vars,\n          op = this._overwrittenProps,\n          dur = this._duration,\n          immediate = !!v.immediateRender,\n          ease = v.ease,\n          startAt = this._startAt,\n          i,\n          initPlugins,\n          pt,\n          p,\n          startVars,\n          l;\n\n      if (v.startAt) {\n        if (startAt) {\n          startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:\"+=100\"}, {x:\"-=100\"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.\n\n          startAt.kill();\n        }\n\n        startVars = {};\n\n        for (p in v.startAt) {\n          //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);\n          startVars[p] = v.startAt[p];\n        }\n\n        startVars.data = \"isStart\";\n        startVars.overwrite = false;\n        startVars.immediateRender = true;\n        startVars.lazy = immediate && v.lazy !== false;\n        startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).\n\n        startVars.onUpdate = v.onUpdate;\n        startVars.onUpdateParams = v.onUpdateParams;\n        startVars.onUpdateScope = v.onUpdateScope || v.callbackScope || this;\n        this._startAt = TweenLite.to(this.target || {}, 0, startVars);\n\n        if (immediate) {\n          if (this._time > 0) {\n            this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).\n          } else if (dur !== 0) {\n            return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.\n          }\n        }\n      } else if (v.runBackwards && dur !== 0) {\n        //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)\n        if (startAt) {\n          startAt.render(-1, true);\n          startAt.kill();\n          this._startAt = null;\n        } else {\n          if (this._time !== 0) {\n            //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0\n            immediate = false;\n          }\n\n          pt = {};\n\n          for (p in v) {\n            //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.\n            if (!_reservedProps[p] || p === \"autoCSS\") {\n              pt[p] = v[p];\n            }\n          }\n\n          pt.overwrite = 0;\n          pt.data = \"isFromStart\"; //we tag the tween with as \"isFromStart\" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a \"from()\" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:\"height\", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.\n\n          pt.lazy = immediate && v.lazy !== false;\n          pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)\n\n          this._startAt = TweenLite.to(this.target, 0, pt);\n\n          if (!immediate) {\n            this._startAt._init(); //ensures that the initial values are recorded\n\n\n            this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.\n\n\n            if (this.vars.immediateRender) {\n              this._startAt = null;\n            }\n          } else if (this._time === 0) {\n            return;\n          }\n        }\n      }\n\n      this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === \"function\" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;\n\n      if (v.easeParams instanceof Array && ease.config) {\n        this._ease = ease.config.apply(ease, v.easeParams);\n      }\n\n      this._easeType = this._ease._type;\n      this._easePower = this._ease._power;\n      this._firstPT = null;\n\n      if (this._targets) {\n        l = this._targets.length;\n\n        for (i = 0; i < l; i++) {\n          if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null, i)) {\n            initPlugins = true;\n          }\n        }\n      } else {\n        initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);\n      }\n\n      if (initPlugins) {\n        TweenLite._onPluginEvent(\"_onInitAllProps\", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite\n\n      }\n\n      if (op) if (!this._firstPT) if (typeof this.target !== \"function\") {\n        //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.\n        this._enabled(false, false);\n      }\n\n      if (v.runBackwards) {\n        pt = this._firstPT;\n\n        while (pt) {\n          pt.s += pt.c;\n          pt.c = -pt.c;\n          pt = pt._next;\n        }\n      }\n\n      this._onUpdate = v.onUpdate;\n      this._initted = true;\n    };\n\n    p._initProps = function (target, propLookup, siblings, overwrittenProps, index) {\n      var p, i, initPlugins, plugin, pt, v;\n\n      if (target == null) {\n        return false;\n      }\n\n      if (_lazyLookup[target._gsTweenID]) {\n        _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)\n\n      }\n\n      if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) {\n        //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check \"nodeType\" on the window inside an iframe.\n        _autoCSS(this.vars, target);\n      }\n\n      for (p in this.vars) {\n        v = this.vars[p];\n\n        if (_reservedProps[p]) {\n          if (v) if (v instanceof Array || v.push && _isArray(v)) if (v.join(\"\").indexOf(\"{self}\") !== -1) {\n            this.vars[p] = v = this._swapSelfInParams(v, this);\n          }\n        } else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {\n          //t - target \t\t[object]\n          //p - property \t\t[string]\n          //s - start\t\t\t[number]\n          //c - change\t\t[number]\n          //f - isFunction\t[boolean]\n          //n - name\t\t\t[string]\n          //pg - isPlugin \t[boolean]\n          //pr - priority\t\t[number]\n          //m - mod           [function | 0]\n          this._firstPT = pt = {\n            _next: this._firstPT,\n            t: plugin,\n            p: \"setRatio\",\n            s: 0,\n            c: 1,\n            f: 1,\n            n: p,\n            pg: 1,\n            pr: plugin._priority,\n            m: 0\n          };\n          i = plugin._overwriteProps.length;\n\n          while (--i > -1) {\n            propLookup[plugin._overwriteProps[i]] = this._firstPT;\n          }\n\n          if (plugin._priority || plugin._onInitAllProps) {\n            initPlugins = true;\n          }\n\n          if (plugin._onDisable || plugin._onEnable) {\n            this._notifyPluginsOfEnabled = true;\n          }\n\n          if (pt._next) {\n            pt._next._prev = pt;\n          }\n        } else {\n          propLookup[p] = _addPropTween.call(this, target, p, \"get\", v, p, 0, null, this.vars.stringFilter, index);\n        }\n      }\n\n      if (overwrittenProps) if (this._kill(overwrittenProps, target)) {\n        //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)\n        return this._initProps(target, propLookup, siblings, overwrittenProps, index);\n      }\n      if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {\n        this._kill(propLookup, target);\n\n        return this._initProps(target, propLookup, siblings, overwrittenProps, index);\n      }\n      if (this._firstPT) if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {\n        //zero duration tweens don't lazy render by default; everything else does.\n        _lazyLookup[target._gsTweenID] = true;\n      }\n      return initPlugins;\n    };\n\n    p.render = function (time, suppressEvents, force) {\n      var self = this,\n          prevTime = self._time,\n          duration = self._duration,\n          prevRawPrevTime = self._rawPrevTime,\n          isComplete,\n          callback,\n          pt,\n          rawPrevTime;\n\n      if (time >= duration - _tinyNum && time >= 0) {\n        //to work around occasional floating point math artifacts.\n        self._totalTime = self._time = duration;\n        self.ratio = self._ease._calcEnd ? self._ease.getRatio(1) : 1;\n\n        if (!self._reversed) {\n          isComplete = true;\n          callback = \"onComplete\";\n          force = force || self._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.\n        }\n\n        if (duration === 0) if (self._initted || !self.vars.lazy || force) {\n          //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the \"playhead\" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's \"playhead\" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.\n          if (self._startTime === self._timeline._duration) {\n            //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.\n            time = 0;\n          }\n\n          if (prevRawPrevTime < 0 || time <= 0 && time >= -_tinyNum || prevRawPrevTime === _tinyNum && self.data !== \"isPause\") if (prevRawPrevTime !== time) {\n            //note: when this.data is \"isPause\", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.\n            force = true;\n\n            if (prevRawPrevTime > _tinyNum) {\n              callback = \"onReverseComplete\";\n            }\n          }\n          self._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.\n        }\n      } else if (time < _tinyNum) {\n        //to work around occasional floating point math artifacts, round super small values to 0.\n        self._totalTime = self._time = 0;\n        self.ratio = self._ease._calcEnd ? self._ease.getRatio(0) : 0;\n\n        if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0) {\n          callback = \"onReverseComplete\";\n          isComplete = self._reversed;\n        }\n\n        if (time > -_tinyNum) {\n          time = 0;\n        } else if (time < 0) {\n          self._active = false;\n          if (duration === 0) if (self._initted || !self.vars.lazy || force) {\n            //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the \"playhead\" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's \"playhead\" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.\n            if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && self.data === \"isPause\")) {\n              force = true;\n            }\n\n            self._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.\n          }\n        }\n\n        if (!self._initted || self._startAt && self._startAt.progress()) {\n          //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately. Also, we check progress() because if startAt has already rendered at its end, we should force a render at its beginning. Otherwise, if you put the playhead directly on top of where a fromTo({immediateRender:false}) starts, and then move it backwards, the from() won't revert its values.\n          force = true;\n        }\n      } else {\n        self._totalTime = self._time = time;\n\n        if (self._easeType) {\n          var r = time / duration,\n              type = self._easeType,\n              pow = self._easePower;\n\n          if (type === 1 || type === 3 && r >= 0.5) {\n            r = 1 - r;\n          }\n\n          if (type === 3) {\n            r *= 2;\n          }\n\n          if (pow === 1) {\n            r *= r;\n          } else if (pow === 2) {\n            r *= r * r;\n          } else if (pow === 3) {\n            r *= r * r * r;\n          } else if (pow === 4) {\n            r *= r * r * r * r;\n          }\n\n          self.ratio = type === 1 ? 1 - r : type === 2 ? r : time / duration < 0.5 ? r / 2 : 1 - r / 2;\n        } else {\n          self.ratio = self._ease.getRatio(time / duration);\n        }\n      }\n\n      if (self._time === prevTime && !force) {\n        return;\n      } else if (!self._initted) {\n        self._init();\n\n        if (!self._initted || self._gc) {\n          //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.\n          return;\n        } else if (!force && self._firstPT && (self.vars.lazy !== false && self._duration || self.vars.lazy && !self._duration)) {\n          self._time = self._totalTime = prevTime;\n          self._rawPrevTime = prevRawPrevTime;\n\n          _lazyTweens.push(self);\n\n          self._lazy = [time, suppressEvents];\n          return;\n        } //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.\n\n\n        if (self._time && !isComplete) {\n          self.ratio = self._ease.getRatio(self._time / duration);\n        } else if (isComplete && self._ease._calcEnd) {\n          self.ratio = self._ease.getRatio(self._time === 0 ? 0 : 1);\n        }\n      }\n\n      if (self._lazy !== false) {\n        //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.\n        self._lazy = false;\n      }\n\n      if (!self._active) if (!self._paused && self._time !== prevTime && time >= 0) {\n        self._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.\n      }\n\n      if (prevTime === 0) {\n        if (self._startAt) {\n          if (time >= 0) {\n            self._startAt.render(time, true, force);\n          } else if (!callback) {\n            callback = \"_dummyGS\"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.\n          }\n        }\n\n        if (self.vars.onStart) if (self._time !== 0 || duration === 0) if (!suppressEvents) {\n          self._callback(\"onStart\");\n        }\n      }\n\n      pt = self._firstPT;\n\n      while (pt) {\n        if (pt.f) {\n          pt.t[pt.p](pt.c * self.ratio + pt.s);\n        } else {\n          pt.t[pt.p] = pt.c * self.ratio + pt.s;\n        }\n\n        pt = pt._next;\n      }\n\n      if (self._onUpdate) {\n        if (time < 0) if (self._startAt && time !== -0.0001) {\n          //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.\n          self._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.\n\n        }\n        if (!suppressEvents) if (self._time !== prevTime || isComplete || force) {\n          self._callback(\"onUpdate\");\n        }\n      }\n\n      if (callback) if (!self._gc || force) {\n        //check _gc because there's a chance that kill() could be called in an onUpdate\n        if (time < 0 && self._startAt && !self._onUpdate && time !== -0.0001) {\n          //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.\n          self._startAt.render(time, true, force);\n        }\n\n        if (isComplete) {\n          if (self._timeline.autoRemoveChildren) {\n            self._enabled(false, false);\n          }\n\n          self._active = false;\n        }\n\n        if (!suppressEvents && self.vars[callback]) {\n          self._callback(callback);\n        }\n\n        if (duration === 0 && self._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {\n          //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the \"time\" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.\n          self._rawPrevTime = 0;\n        }\n      }\n    };\n\n    p._kill = function (vars, target, overwritingTween) {\n      if (vars === \"all\") {\n        vars = null;\n      }\n\n      if (vars == null) if (target == null || target === this.target) {\n        this._lazy = false;\n        return this._enabled(false, false);\n      }\n      target = typeof target !== \"string\" ? target || this._targets || this.target : TweenLite.selector(target) || target;\n      var simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline,\n          firstPT = this._firstPT,\n          i,\n          overwrittenProps,\n          p,\n          pt,\n          propLookup,\n          changed,\n          killProps,\n          record,\n          killed;\n\n      if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== \"number\") {\n        i = target.length;\n\n        while (--i > -1) {\n          if (this._kill(vars, target[i], overwritingTween)) {\n            changed = true;\n          }\n        }\n      } else {\n        if (this._targets) {\n          i = this._targets.length;\n\n          while (--i > -1) {\n            if (target === this._targets[i]) {\n              propLookup = this._propLookup[i] || {};\n              this._overwrittenProps = this._overwrittenProps || [];\n              overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : \"all\";\n              break;\n            }\n          }\n        } else if (target !== this.target) {\n          return false;\n        } else {\n          propLookup = this._propLookup;\n          overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : \"all\";\n        }\n\n        if (propLookup) {\n          killProps = vars || propLookup;\n          record = vars !== overwrittenProps && overwrittenProps !== \"all\" && vars !== propLookup && (_typeof(vars) !== \"object\" || !vars._tempKill); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)\n\n          if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {\n            for (p in killProps) {\n              if (propLookup[p]) {\n                if (!killed) {\n                  killed = [];\n                }\n\n                killed.push(p);\n              }\n            }\n\n            if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {\n              //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).\n              return false;\n            }\n          }\n\n          for (p in killProps) {\n            if (pt = propLookup[p]) {\n              if (simultaneousOverwrite) {\n                //if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.\n                if (pt.f) {\n                  pt.t[pt.p](pt.s);\n                } else {\n                  pt.t[pt.p] = pt.s;\n                }\n\n                changed = true;\n              }\n\n              if (pt.pg && pt.t._kill(killProps)) {\n                changed = true; //some plugins need to be notified so they can perform cleanup tasks first\n              }\n\n              if (!pt.pg || pt.t._overwriteProps.length === 0) {\n                if (pt._prev) {\n                  pt._prev._next = pt._next;\n                } else if (pt === this._firstPT) {\n                  this._firstPT = pt._next;\n                }\n\n                if (pt._next) {\n                  pt._next._prev = pt._prev;\n                }\n\n                pt._next = pt._prev = null;\n              }\n\n              delete propLookup[p];\n            }\n\n            if (record) {\n              overwrittenProps[p] = 1;\n            }\n          }\n\n          if (!this._firstPT && this._initted && firstPT) {\n            //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.\n            this._enabled(false, false);\n          }\n        }\n      }\n\n      return changed;\n    };\n\n    p.invalidate = function () {\n      if (this._notifyPluginsOfEnabled) {\n        TweenLite._onPluginEvent(\"_onDisable\", this);\n      }\n\n      var t = this._time;\n      this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;\n      this._notifyPluginsOfEnabled = this._active = this._lazy = false;\n      this._propLookup = this._targets ? {} : [];\n      Animation.prototype.invalidate.call(this);\n\n      if (this.vars.immediateRender) {\n        this._time = -_tinyNum; //forces a render without having to set the render() \"force\" parameter to true because we want to allow lazying by default (using the \"force\" parameter always forces an immediate full render)\n\n        this.render(t, false, this.vars.lazy !== false);\n      }\n\n      return this;\n    };\n\n    p._enabled = function (enabled, ignoreTimeline) {\n      if (!_tickerActive) {\n        _ticker.wake();\n      }\n\n      if (enabled && this._gc) {\n        var targets = this._targets,\n            i;\n\n        if (targets) {\n          i = targets.length;\n\n          while (--i > -1) {\n            this._siblings[i] = _register(targets[i], this, true);\n          }\n        } else {\n          this._siblings = _register(this.target, this, true);\n        }\n      }\n\n      Animation.prototype._enabled.call(this, enabled, ignoreTimeline);\n\n      if (this._notifyPluginsOfEnabled) if (this._firstPT) {\n        return TweenLite._onPluginEvent(enabled ? \"_onEnable\" : \"_onDisable\", this);\n      }\n      return false;\n    }; //----TweenLite static methods -----------------------------------------------------\n\n\n    TweenLite.to = function (target, duration, vars) {\n      return new TweenLite(target, duration, vars);\n    };\n\n    TweenLite.from = function (target, duration, vars) {\n      vars.runBackwards = true;\n      vars.immediateRender = vars.immediateRender != false;\n      return new TweenLite(target, duration, vars);\n    };\n\n    TweenLite.fromTo = function (target, duration, fromVars, toVars) {\n      toVars.startAt = fromVars;\n      toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;\n      return new TweenLite(target, duration, toVars);\n    };\n\n    TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {\n      return new TweenLite(callback, 0, {\n        delay: delay,\n        onComplete: callback,\n        onCompleteParams: params,\n        callbackScope: scope,\n        onReverseComplete: callback,\n        onReverseCompleteParams: params,\n        immediateRender: false,\n        lazy: false,\n        useFrames: useFrames,\n        overwrite: 0\n      });\n    };\n\n    TweenLite.set = function (target, vars) {\n      return new TweenLite(target, 0, vars);\n    };\n\n    TweenLite.getTweensOf = function (target, onlyActive) {\n      if (target == null) {\n        return [];\n      }\n\n      target = typeof target !== \"string\" ? target : TweenLite.selector(target) || target;\n      var i, a, j, t;\n\n      if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== \"number\") {\n        i = target.length;\n        a = [];\n\n        while (--i > -1) {\n          a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));\n        }\n\n        i = a.length; //now get rid of any duplicates (tweens of arrays of objects could cause duplicates)\n\n        while (--i > -1) {\n          t = a[i];\n          j = i;\n\n          while (--j > -1) {\n            if (t === a[j]) {\n              a.splice(i, 1);\n            }\n          }\n        }\n      } else if (target._gsTweenID) {\n        a = _register(target).concat();\n        i = a.length;\n\n        while (--i > -1) {\n          if (a[i]._gc || onlyActive && !a[i].isActive()) {\n            a.splice(i, 1);\n          }\n        }\n      }\n\n      return a || [];\n    };\n\n    TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {\n      if (_typeof(onlyActive) === \"object\") {\n        vars = onlyActive; //for backwards compatibility (before \"onlyActive\" parameter was inserted)\n\n        onlyActive = false;\n      }\n\n      var a = TweenLite.getTweensOf(target, onlyActive),\n          i = a.length;\n\n      while (--i > -1) {\n        a[i]._kill(vars, target);\n      }\n    };\n    /*\n     * ----------------------------------------------------------------\n     * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)\n     * ----------------------------------------------------------------\n     */\n\n\n    var TweenPlugin = _class(\"plugins.TweenPlugin\", function (props, priority) {\n      this._overwriteProps = (props || \"\").split(\",\");\n      this._propName = this._overwriteProps[0];\n      this._priority = priority || 0;\n      this._super = TweenPlugin.prototype;\n    }, true);\n\n    p = TweenPlugin.prototype;\n    TweenPlugin.version = \"1.19.0\";\n    TweenPlugin.API = 2;\n    p._firstPT = null;\n    p._addTween = _addPropTween;\n    p.setRatio = _setRatio;\n\n    p._kill = function (lookup) {\n      var a = this._overwriteProps,\n          pt = this._firstPT,\n          i;\n\n      if (lookup[this._propName] != null) {\n        this._overwriteProps = [];\n      } else {\n        i = a.length;\n\n        while (--i > -1) {\n          if (lookup[a[i]] != null) {\n            a.splice(i, 1);\n          }\n        }\n      }\n\n      while (pt) {\n        if (lookup[pt.n] != null) {\n          if (pt._next) {\n            pt._next._prev = pt._prev;\n          }\n\n          if (pt._prev) {\n            pt._prev._next = pt._next;\n            pt._prev = null;\n          } else if (this._firstPT === pt) {\n            this._firstPT = pt._next;\n          }\n        }\n\n        pt = pt._next;\n      }\n\n      return false;\n    };\n\n    p._mod = p._roundProps = function (lookup) {\n      var pt = this._firstPT,\n          val;\n\n      while (pt) {\n        val = lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + \"_\").join(\"\")];\n\n        if (val && typeof val === \"function\") {\n          //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.\n          if (pt.f === 2) {\n            pt.t._applyPT.m = val;\n          } else {\n            pt.m = val;\n          }\n        }\n\n        pt = pt._next;\n      }\n    };\n\n    TweenLite._onPluginEvent = function (type, tween) {\n      var pt = tween._firstPT,\n          changed,\n          pt2,\n          first,\n          last,\n          next;\n\n      if (type === \"_onInitAllProps\") {\n        //sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.\n        while (pt) {\n          next = pt._next;\n          pt2 = first;\n\n          while (pt2 && pt2.pr > pt.pr) {\n            pt2 = pt2._next;\n          }\n\n          if (pt._prev = pt2 ? pt2._prev : last) {\n            pt._prev._next = pt;\n          } else {\n            first = pt;\n          }\n\n          if (pt._next = pt2) {\n            pt2._prev = pt;\n          } else {\n            last = pt;\n          }\n\n          pt = next;\n        }\n\n        pt = tween._firstPT = first;\n      }\n\n      while (pt) {\n        if (pt.pg) if (typeof pt.t[type] === \"function\") if (pt.t[type]()) {\n          changed = true;\n        }\n        pt = pt._next;\n      }\n\n      return changed;\n    };\n\n    TweenPlugin.activate = function (plugins) {\n      var i = plugins.length;\n\n      while (--i > -1) {\n        if (plugins[i].API === TweenPlugin.API) {\n          _plugins[new plugins[i]()._propName] = plugins[i];\n        }\n      }\n\n      return true;\n    }; //provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.\n\n\n    _gsDefine.plugin = function (config) {\n      if (!config || !config.propName || !config.init || !config.API) {\n        throw \"illegal plugin definition.\";\n      }\n\n      var propName = config.propName,\n          priority = config.priority || 0,\n          overwriteProps = config.overwriteProps,\n          map = {\n        init: \"_onInitTween\",\n        set: \"setRatio\",\n        kill: \"_kill\",\n        round: \"_mod\",\n        mod: \"_mod\",\n        initAll: \"_onInitAllProps\"\n      },\n          Plugin = _class(\"plugins.\" + propName.charAt(0).toUpperCase() + propName.substr(1) + \"Plugin\", function () {\n        TweenPlugin.call(this, propName, priority);\n        this._overwriteProps = overwriteProps || [];\n      }, config.global === true),\n          p = Plugin.prototype = new TweenPlugin(propName),\n          prop;\n\n      p.constructor = Plugin;\n      Plugin.API = config.API;\n\n      for (prop in map) {\n        if (typeof config[prop] === \"function\") {\n          p[map[prop]] = config[prop];\n        }\n      }\n\n      Plugin.version = config.version;\n      TweenPlugin.activate([Plugin]);\n      return Plugin;\n    }; //now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.\n\n\n    a = window._gsQueue;\n\n    if (a) {\n      for (i = 0; i < a.length; i++) {\n        a[i]();\n      }\n\n      for (p in _defLookup) {\n        if (!_defLookup[p].func) {\n          window.console.log(\"GSAP encountered missing dependency: \" + p);\n        }\n      }\n    }\n\n    _tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated\n\n    return TweenLite;\n  }(_gsScope);\n\n  var globals = _gsScope.GreenSockGlobals;\n  var nonGlobals = globals.com.greensock;\n  var SimpleTimeline = nonGlobals.core.SimpleTimeline;\n  var Animation = nonGlobals.core.Animation;\n  var Ease = globals.Ease;\n  var Linear = globals.Linear;\n  var Power1 = globals.Power1;\n  var Power2 = globals.Power2;\n  var Power3 = globals.Power3;\n  var Power4 = globals.Power4;\n  var TweenPlugin = globals.TweenPlugin;\n  var EventDispatcher = nonGlobals.events.EventDispatcher;\n  /*!\n   * VERSION: 2.1.3\n   * DATE: 2019-05-17\n   * UPDATES AND DOCS AT: http://greensock.com\n   *\n   * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.\n   * This work is subject to the terms at http://greensock.com/standard-license or for\n   * Club GreenSock members, the software agreement that was issued with your membership.\n   * \n   * @author: Jack Doyle, jack@greensock.com\n   **/\n\n  _gsScope._gsDefine(\"TweenMax\", [\"core.Animation\", \"core.SimpleTimeline\", \"TweenLite\"], function () {\n    var _slice = function _slice(a) {\n      //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()\n      var b = [],\n          l = a.length,\n          i;\n\n      for (i = 0; i !== l; b.push(a[i++])) {\n        ;\n      }\n\n      return b;\n    },\n        _applyCycle = function _applyCycle(vars, targets, i) {\n      var alt = vars.cycle,\n          p,\n          val;\n\n      for (p in alt) {\n        val = alt[p];\n        vars[p] = typeof val === \"function\" ? val(i, targets[i], targets) : val[i % val.length];\n      }\n\n      delete vars.cycle;\n    },\n        //for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following\n    _distribute = function _distribute(v) {\n      if (typeof v === \"function\") {\n        return v;\n      }\n\n      var vars = _typeof(v) === \"object\" ? v : {\n        each: v\n      },\n          //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total \"amount\" that's chunked out among them all.\n      ease = vars.ease,\n          from = vars.from || 0,\n          base = vars.base || 0,\n          cache = {},\n          isFromKeyword = isNaN(from),\n          axis = vars.axis,\n          ratio = {\n        center: 0.5,\n        end: 1\n      }[from] || 0;\n      return function (i, target, a) {\n        var l = (a || vars).length,\n            distances = cache[l],\n            originX,\n            originY,\n            x,\n            y,\n            d,\n            j,\n            max,\n            min,\n            wrap;\n\n        if (!distances) {\n          wrap = vars.grid === \"auto\" ? 0 : (vars.grid || [Infinity])[0];\n\n          if (!wrap) {\n            max = -Infinity;\n\n            while (max < (max = a[wrap++].getBoundingClientRect().left) && wrap < l) {}\n\n            wrap--;\n          }\n\n          distances = cache[l] = [];\n          originX = isFromKeyword ? Math.min(wrap, l) * ratio - 0.5 : from % wrap;\n          originY = isFromKeyword ? l * ratio / wrap - 0.5 : from / wrap | 0;\n          max = 0;\n          min = Infinity;\n\n          for (j = 0; j < l; j++) {\n            x = j % wrap - originX;\n            y = originY - (j / wrap | 0);\n            distances[j] = d = !axis ? Math.sqrt(x * x + y * y) : Math.abs(axis === \"y\" ? y : x);\n\n            if (d > max) {\n              max = d;\n            }\n\n            if (d < min) {\n              min = d;\n            }\n          }\n\n          distances.max = max - min;\n          distances.min = min;\n          distances.v = l = vars.amount || vars.each * (wrap > l ? l - 1 : !axis ? Math.max(wrap, l / wrap) : axis === \"y\" ? l / wrap : wrap) || 0;\n          distances.b = l < 0 ? base - l : base;\n        }\n\n        l = (distances[i] - distances.min) / distances.max;\n        return distances.b + (ease ? ease.getRatio(l) : l) * distances.v;\n      };\n    },\n        TweenMax = function TweenMax(target, duration, vars) {\n      TweenLite.call(this, target, duration, vars);\n      this._cycle = 0;\n      this._yoyo = this.vars.yoyo === true || !!this.vars.yoyoEase;\n      this._repeat = this.vars.repeat || 0;\n      this._repeatDelay = this.vars.repeatDelay || 0;\n\n      if (this._repeat) {\n        this._uncache(true); //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.\n\n      }\n\n      this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this \"hot\" method)\n    },\n        _tinyNum = 0.00000001,\n        TweenLiteInternals = TweenLite._internals,\n        _isSelector = TweenLiteInternals.isSelector,\n        _isArray = TweenLiteInternals.isArray,\n        p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),\n        _blankArray = [];\n\n    TweenMax.version = \"2.1.3\";\n    p.constructor = TweenMax;\n    p.kill()._gc = false;\n    TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;\n    TweenMax.getTweensOf = TweenLite.getTweensOf;\n    TweenMax.lagSmoothing = TweenLite.lagSmoothing;\n    TweenMax.ticker = TweenLite.ticker;\n    TweenMax.render = TweenLite.render;\n    TweenMax.distribute = _distribute;\n\n    p.invalidate = function () {\n      this._yoyo = this.vars.yoyo === true || !!this.vars.yoyoEase;\n      this._repeat = this.vars.repeat || 0;\n      this._repeatDelay = this.vars.repeatDelay || 0;\n      this._yoyoEase = null;\n\n      this._uncache(true);\n\n      return TweenLite.prototype.invalidate.call(this);\n    };\n\n    p.updateTo = function (vars, resetDuration) {\n      var self = this,\n          curRatio = self.ratio,\n          immediate = self.vars.immediateRender || vars.immediateRender,\n          p;\n\n      if (resetDuration && self._startTime < self._timeline._time) {\n        self._startTime = self._timeline._time;\n\n        self._uncache(false);\n\n        if (self._gc) {\n          self._enabled(true, false);\n        } else {\n          self._timeline.insert(self, self._startTime - self._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.\n\n        }\n      }\n\n      for (p in vars) {\n        self.vars[p] = vars[p];\n      }\n\n      if (self._initted || immediate) {\n        if (resetDuration) {\n          self._initted = false;\n\n          if (immediate) {\n            self.render(0, true, true);\n          }\n        } else {\n          if (self._gc) {\n            self._enabled(true, false);\n          }\n\n          if (self._notifyPluginsOfEnabled && self._firstPT) {\n            TweenLite._onPluginEvent(\"_onDisable\", self); //in case a plugin like MotionBlur must perform some cleanup tasks\n\n          }\n\n          if (self._time / self._duration > 0.998) {\n            //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards.\n            var prevTime = self._totalTime;\n            self.render(0, true, false);\n            self._initted = false;\n            self.render(prevTime, true, false);\n          } else {\n            self._initted = false;\n\n            self._init();\n\n            if (self._time > 0 || immediate) {\n              var inv = 1 / (1 - curRatio),\n                  pt = self._firstPT,\n                  endValue;\n\n              while (pt) {\n                endValue = pt.s + pt.c;\n                pt.c *= inv;\n                pt.s = endValue - pt.c;\n                pt = pt._next;\n              }\n            }\n          }\n        }\n      }\n\n      return self;\n    };\n\n    p.render = function (time, suppressEvents, force) {\n      if (!this._initted) if (this._duration === 0 && this.vars.repeat) {\n        //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.\n        this.invalidate();\n      }\n      var self = this,\n          totalDur = !self._dirty ? self._totalDuration : self.totalDuration(),\n          prevTime = self._time,\n          prevTotalTime = self._totalTime,\n          prevCycle = self._cycle,\n          duration = self._duration,\n          prevRawPrevTime = self._rawPrevTime,\n          isComplete,\n          callback,\n          pt,\n          cycleDuration,\n          r,\n          type,\n          pow,\n          rawPrevTime,\n          yoyoEase;\n\n      if (time >= totalDur - _tinyNum && time >= 0) {\n        //to work around occasional floating point math artifacts.\n        self._totalTime = totalDur;\n        self._cycle = self._repeat;\n\n        if (self._yoyo && (self._cycle & 1) !== 0) {\n          self._time = 0;\n          self.ratio = self._ease._calcEnd ? self._ease.getRatio(0) : 0;\n        } else {\n          self._time = duration;\n          self.ratio = self._ease._calcEnd ? self._ease.getRatio(1) : 1;\n        }\n\n        if (!self._reversed) {\n          isComplete = true;\n          callback = \"onComplete\";\n          force = force || self._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.\n        }\n\n        if (duration === 0) if (self._initted || !self.vars.lazy || force) {\n          //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the \"playhead\" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's \"playhead\" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.\n          if (self._startTime === self._timeline._duration) {\n            //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.\n            time = 0;\n          }\n\n          if (prevRawPrevTime < 0 || time <= 0 && time >= -_tinyNum || prevRawPrevTime === _tinyNum && self.data !== \"isPause\") if (prevRawPrevTime !== time) {\n            //note: when this.data is \"isPause\", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.\n            force = true;\n\n            if (prevRawPrevTime > _tinyNum) {\n              callback = \"onReverseComplete\";\n            }\n          }\n          self._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.\n        }\n      } else if (time < _tinyNum) {\n        //to work around occasional floating point math artifacts, round super small values to 0.\n        self._totalTime = self._time = self._cycle = 0;\n        self.ratio = self._ease._calcEnd ? self._ease.getRatio(0) : 0;\n\n        if (prevTotalTime !== 0 || duration === 0 && prevRawPrevTime > 0) {\n          callback = \"onReverseComplete\";\n          isComplete = self._reversed;\n        }\n\n        if (time > -_tinyNum) {\n          time = 0;\n        } else if (time < 0) {\n          self._active = false;\n          if (duration === 0) if (self._initted || !self.vars.lazy || force) {\n            //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the \"playhead\" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's \"playhead\" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.\n            if (prevRawPrevTime >= 0) {\n              force = true;\n            }\n\n            self._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.\n          }\n        }\n\n        if (!self._initted) {\n          //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.\n          force = true;\n        }\n      } else {\n        self._totalTime = self._time = time;\n\n        if (self._repeat !== 0) {\n          cycleDuration = duration + self._repeatDelay;\n          self._cycle = self._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n\n          if (self._cycle !== 0) if (self._cycle === self._totalTime / cycleDuration && prevTotalTime <= time) {\n            self._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)\n          }\n          self._time = self._totalTime - self._cycle * cycleDuration;\n          if (self._yoyo) if ((self._cycle & 1) !== 0) {\n            self._time = duration - self._time;\n            yoyoEase = self._yoyoEase || self.vars.yoyoEase; //note: we don't set this._yoyoEase in _init() like we do other properties because it's TweenMax-specific and doing it here allows us to optimize performance (most tweens don't have a yoyoEase). Note that we also must skip the this.ratio calculation further down right after we _init() in this function, because we're doing it here.\n\n            if (yoyoEase) {\n              if (!self._yoyoEase) {\n                if (yoyoEase === true && !self._initted) {\n                  //if it's not initted and yoyoEase is true, this._ease won't have been populated yet so we must discern it here.\n                  yoyoEase = self.vars.ease;\n                  self._yoyoEase = yoyoEase = !yoyoEase ? TweenLite.defaultEase : yoyoEase instanceof Ease ? yoyoEase : typeof yoyoEase === \"function\" ? new Ease(yoyoEase, self.vars.easeParams) : Ease.map[yoyoEase] || TweenLite.defaultEase;\n                } else {\n                  self._yoyoEase = yoyoEase = yoyoEase === true ? self._ease : yoyoEase instanceof Ease ? yoyoEase : Ease.map[yoyoEase];\n                }\n              }\n\n              self.ratio = yoyoEase ? 1 - yoyoEase.getRatio((duration - self._time) / duration) : 0;\n            }\n          }\n\n          if (self._time > duration) {\n            self._time = duration;\n          } else if (self._time < 0) {\n            self._time = 0;\n          }\n        }\n\n        if (self._easeType && !yoyoEase) {\n          r = self._time / duration;\n          type = self._easeType;\n          pow = self._easePower;\n\n          if (type === 1 || type === 3 && r >= 0.5) {\n            r = 1 - r;\n          }\n\n          if (type === 3) {\n            r *= 2;\n          }\n\n          if (pow === 1) {\n            r *= r;\n          } else if (pow === 2) {\n            r *= r * r;\n          } else if (pow === 3) {\n            r *= r * r * r;\n          } else if (pow === 4) {\n            r *= r * r * r * r;\n          }\n\n          self.ratio = type === 1 ? 1 - r : type === 2 ? r : self._time / duration < 0.5 ? r / 2 : 1 - r / 2;\n        } else if (!yoyoEase) {\n          self.ratio = self._ease.getRatio(self._time / duration);\n        }\n      }\n\n      if (prevTime === self._time && !force && prevCycle === self._cycle) {\n        if (prevTotalTime !== self._totalTime) if (self._onUpdate) if (!suppressEvents) {\n          //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.\n          self._callback(\"onUpdate\");\n        }\n        return;\n      } else if (!self._initted) {\n        self._init();\n\n        if (!self._initted || self._gc) {\n          //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.\n          return;\n        } else if (!force && self._firstPT && (self.vars.lazy !== false && self._duration || self.vars.lazy && !self._duration)) {\n          //we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.\n          self._time = prevTime;\n          self._totalTime = prevTotalTime;\n          self._rawPrevTime = prevRawPrevTime;\n          self._cycle = prevCycle;\n          TweenLiteInternals.lazyTweens.push(self);\n          self._lazy = [time, suppressEvents];\n          return;\n        } //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.\n\n\n        if (self._time && !isComplete && !yoyoEase) {\n          self.ratio = self._ease.getRatio(self._time / duration);\n        } else if (isComplete && this._ease._calcEnd && !yoyoEase) {\n          self.ratio = self._ease.getRatio(self._time === 0 ? 0 : 1);\n        }\n      }\n\n      if (self._lazy !== false) {\n        self._lazy = false;\n      }\n\n      if (!self._active) if (!self._paused && self._time !== prevTime && time >= 0) {\n        self._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.\n      }\n\n      if (prevTotalTime === 0) {\n        if (self._initted === 2 && time > 0) {\n          self._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true\n\n        }\n\n        if (self._startAt) {\n          if (time >= 0) {\n            self._startAt.render(time, true, force);\n          } else if (!callback) {\n            callback = \"_dummyGS\"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.\n          }\n        }\n\n        if (self.vars.onStart) if (self._totalTime !== 0 || duration === 0) if (!suppressEvents) {\n          self._callback(\"onStart\");\n        }\n      }\n\n      pt = self._firstPT;\n\n      while (pt) {\n        if (pt.f) {\n          pt.t[pt.p](pt.c * self.ratio + pt.s);\n        } else {\n          pt.t[pt.p] = pt.c * self.ratio + pt.s;\n        }\n\n        pt = pt._next;\n      }\n\n      if (self._onUpdate) {\n        if (time < 0) if (self._startAt && self._startTime) {\n          //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.\n          self._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.\n\n        }\n        if (!suppressEvents) if (self._totalTime !== prevTotalTime || callback) {\n          self._callback(\"onUpdate\");\n        }\n      }\n\n      if (self._cycle !== prevCycle) if (!suppressEvents) if (!self._gc) if (self.vars.onRepeat) {\n        self._callback(\"onRepeat\");\n      }\n      if (callback) if (!self._gc || force) {\n        //check gc because there's a chance that kill() could be called in an onUpdate\n        if (time < 0 && self._startAt && !self._onUpdate && self._startTime) {\n          //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.\n          self._startAt.render(time, true, force);\n        }\n\n        if (isComplete) {\n          if (self._timeline.autoRemoveChildren) {\n            self._enabled(false, false);\n          }\n\n          self._active = false;\n        }\n\n        if (!suppressEvents && self.vars[callback]) {\n          self._callback(callback);\n        }\n\n        if (duration === 0 && self._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {\n          //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the \"time\" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.\n          self._rawPrevTime = 0;\n        }\n      }\n    }; //---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------\n\n\n    TweenMax.to = function (target, duration, vars) {\n      return new TweenMax(target, duration, vars);\n    };\n\n    TweenMax.from = function (target, duration, vars) {\n      vars.runBackwards = true;\n      vars.immediateRender = vars.immediateRender != false;\n      return new TweenMax(target, duration, vars);\n    };\n\n    TweenMax.fromTo = function (target, duration, fromVars, toVars) {\n      toVars.startAt = fromVars;\n      toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;\n      return new TweenMax(target, duration, toVars);\n    };\n\n    TweenMax.staggerTo = TweenMax.allTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {\n      var a = [],\n          staggerFunc = _distribute(vars.stagger || stagger),\n          cycle = vars.cycle,\n          fromCycle = (vars.startAt || _blankArray).cycle,\n          l,\n          copy,\n          i,\n          p;\n\n      if (!_isArray(targets)) {\n        if (typeof targets === \"string\") {\n          targets = TweenLite.selector(targets) || targets;\n        }\n\n        if (_isSelector(targets)) {\n          targets = _slice(targets);\n        }\n      }\n\n      targets = targets || [];\n      l = targets.length - 1;\n\n      for (i = 0; i <= l; i++) {\n        copy = {};\n\n        for (p in vars) {\n          copy[p] = vars[p];\n        }\n\n        if (cycle) {\n          _applyCycle(copy, targets, i);\n\n          if (copy.duration != null) {\n            duration = copy.duration;\n            delete copy.duration;\n          }\n        }\n\n        if (fromCycle) {\n          fromCycle = copy.startAt = {};\n\n          for (p in vars.startAt) {\n            fromCycle[p] = vars.startAt[p];\n          }\n\n          _applyCycle(copy.startAt, targets, i);\n        }\n\n        copy.delay = staggerFunc(i, targets[i], targets) + (copy.delay || 0);\n\n        if (i === l && onCompleteAll) {\n          copy.onComplete = function () {\n            if (vars.onComplete) {\n              vars.onComplete.apply(vars.onCompleteScope || this, arguments);\n            }\n\n            onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);\n          };\n        }\n\n        a[i] = new TweenMax(targets[i], duration, copy);\n      }\n\n      return a;\n    };\n\n    TweenMax.staggerFrom = TweenMax.allFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {\n      vars.runBackwards = true;\n      vars.immediateRender = vars.immediateRender != false;\n      return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);\n    };\n\n    TweenMax.staggerFromTo = TweenMax.allFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {\n      toVars.startAt = fromVars;\n      toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;\n      return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);\n    };\n\n    TweenMax.delayedCall = function (delay, callback, params, scope, useFrames) {\n      return new TweenMax(callback, 0, {\n        delay: delay,\n        onComplete: callback,\n        onCompleteParams: params,\n        callbackScope: scope,\n        onReverseComplete: callback,\n        onReverseCompleteParams: params,\n        immediateRender: false,\n        useFrames: useFrames,\n        overwrite: 0\n      });\n    };\n\n    TweenMax.set = function (target, vars) {\n      return new TweenMax(target, 0, vars);\n    };\n\n    TweenMax.isTweening = function (target) {\n      return TweenLite.getTweensOf(target, true).length > 0;\n    };\n\n    var _getChildrenOf = function _getChildrenOf(timeline, includeTimelines) {\n      var a = [],\n          cnt = 0,\n          tween = timeline._first;\n\n      while (tween) {\n        if (tween instanceof TweenLite) {\n          a[cnt++] = tween;\n        } else {\n          if (includeTimelines) {\n            a[cnt++] = tween;\n          }\n\n          a = a.concat(_getChildrenOf(tween, includeTimelines));\n          cnt = a.length;\n        }\n\n        tween = tween._next;\n      }\n\n      return a;\n    },\n        getAllTweens = TweenMax.getAllTweens = function (includeTimelines) {\n      return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines));\n    };\n\n    TweenMax.killAll = function (complete, tweens, delayedCalls, timelines) {\n      if (tweens == null) {\n        tweens = true;\n      }\n\n      if (delayedCalls == null) {\n        delayedCalls = true;\n      }\n\n      var a = getAllTweens(timelines != false),\n          l = a.length,\n          allTrue = tweens && delayedCalls && timelines,\n          isDC,\n          tween,\n          i;\n\n      for (i = 0; i < l; i++) {\n        tween = a[i];\n\n        if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {\n          if (complete) {\n            tween.totalTime(tween._reversed ? 0 : tween.totalDuration());\n          } else {\n            tween._enabled(false, false);\n          }\n        }\n      }\n    };\n\n    TweenMax.killChildTweensOf = function (parent, complete) {\n      if (parent == null) {\n        return;\n      }\n\n      var tl = TweenLiteInternals.tweenLookup,\n          a,\n          curParent,\n          p,\n          i,\n          l;\n\n      if (typeof parent === \"string\") {\n        parent = TweenLite.selector(parent) || parent;\n      }\n\n      if (_isSelector(parent)) {\n        parent = _slice(parent);\n      }\n\n      if (_isArray(parent)) {\n        i = parent.length;\n\n        while (--i > -1) {\n          TweenMax.killChildTweensOf(parent[i], complete);\n        }\n\n        return;\n      }\n\n      a = [];\n\n      for (p in tl) {\n        curParent = tl[p].target.parentNode;\n\n        while (curParent) {\n          if (curParent === parent) {\n            a = a.concat(tl[p].tweens);\n          }\n\n          curParent = curParent.parentNode;\n        }\n      }\n\n      l = a.length;\n\n      for (i = 0; i < l; i++) {\n        if (complete) {\n          a[i].totalTime(a[i].totalDuration());\n        }\n\n        a[i]._enabled(false, false);\n      }\n    };\n\n    var _changePause = function _changePause(pause, tweens, delayedCalls, timelines) {\n      tweens = tweens !== false;\n      delayedCalls = delayedCalls !== false;\n      timelines = timelines !== false;\n      var a = getAllTweens(timelines),\n          allTrue = tweens && delayedCalls && timelines,\n          i = a.length,\n          isDC,\n          tween;\n\n      while (--i > -1) {\n        tween = a[i];\n\n        if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {\n          tween.paused(pause);\n        }\n      }\n    };\n\n    TweenMax.pauseAll = function (tweens, delayedCalls, timelines) {\n      _changePause(true, tweens, delayedCalls, timelines);\n    };\n\n    TweenMax.resumeAll = function (tweens, delayedCalls, timelines) {\n      _changePause(false, tweens, delayedCalls, timelines);\n    };\n\n    TweenMax.globalTimeScale = function (value) {\n      var tl = Animation._rootTimeline,\n          t = TweenLite.ticker.time;\n\n      if (!arguments.length) {\n        return tl._timeScale;\n      }\n\n      value = value || _tinyNum; //can't allow zero because it'll throw the math off\n\n      tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;\n      tl = Animation._rootFramesTimeline;\n      t = TweenLite.ticker.frame;\n      tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;\n      tl._timeScale = Animation._rootTimeline._timeScale = value;\n      return value;\n    }; //---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------\n\n\n    p.progress = function (value, suppressEvents) {\n      return !arguments.length ? this.duration() ? this._time / this._duration : this.ratio : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);\n    };\n\n    p.totalProgress = function (value, suppressEvents) {\n      return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);\n    };\n\n    p.time = function (value, suppressEvents) {\n      if (!arguments.length) {\n        return this._time;\n      }\n\n      if (this._dirty) {\n        this.totalDuration();\n      }\n\n      var duration = this._duration,\n          cycle = this._cycle,\n          cycleDur = cycle * (duration + this._repeatDelay);\n\n      if (value > duration) {\n        value = duration;\n      }\n\n      return this.totalTime(this._yoyo && cycle & 1 ? duration - value + cycleDur : this._repeat ? value + cycleDur : value, suppressEvents);\n    };\n\n    p.duration = function (value) {\n      if (!arguments.length) {\n        return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.\n      }\n\n      return Animation.prototype.duration.call(this, value);\n    };\n\n    p.totalDuration = function (value) {\n      if (!arguments.length) {\n        if (this._dirty) {\n          //instead of Infinity, we use 999999999999 so that we can accommodate reverses\n          this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;\n          this._dirty = false;\n        }\n\n        return this._totalDuration;\n      }\n\n      return this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1));\n    };\n\n    p.repeat = function (value) {\n      if (!arguments.length) {\n        return this._repeat;\n      }\n\n      this._repeat = value;\n      return this._uncache(true);\n    };\n\n    p.repeatDelay = function (value) {\n      if (!arguments.length) {\n        return this._repeatDelay;\n      }\n\n      this._repeatDelay = value;\n      return this._uncache(true);\n    };\n\n    p.yoyo = function (value) {\n      if (!arguments.length) {\n        return this._yoyo;\n      }\n\n      this._yoyo = value;\n      return this;\n    };\n\n    return TweenMax;\n  }, true);\n\n  var TweenMax = globals.TweenMax;\n  var pluginFacePointer = {\n    models: 'weboji',\n    enabled: false,\n    tags: ['browser'],\n    // The pointer element\n    $pointer: null,\n    // Pointers position\n    pointer: {\n      x: -20,\n      y: -20\n    },\n    // Used to smoothen out the pointer\n    tween: {\n      x: 0,\n      y: 0,\n      positionList: []\n    },\n    config: {\n      // Used to offset the pointer, like when the webcam is not in front of you\n      offset: {\n        // Nudge the pointer by this amount\n        x: 0,\n        y: 0,\n        // Calibrate the head (in degrees)\n        pitch: 10,\n        yaw: 0,\n        roll: 0\n      },\n      // Sets how senstive the pointer is\n      speed: {\n        x: 1,\n        y: 1\n      }\n    },\n    onEnable: function onEnable() {\n      var _this$$pointer;\n\n      if (!this.$pointer) {\n        var $pointer = document.createElement('div');\n        $pointer.classList.add('handsfree-pointer', 'handsfree-pointer-face', 'handsfree-hide-when-started-without-weboji');\n        document.body.appendChild($pointer);\n        this.$pointer = $pointer;\n      }\n\n      (_this$$pointer = this.$pointer) === null || _this$$pointer === void 0 ? void 0 : _this$$pointer.classList.remove('handsfree-hidden');\n    },\n    onFrame: function onFrame(_ref3) {\n      var weboji = _ref3.weboji;\n      // Get X/Y as if looking straight aweboji\n      var x = weboji.translation[0] * window.outerWidth;\n      var y = window.outerHeight - weboji.translation[1] * window.outerHeight;\n      var z = (1 - weboji.translation[2]) * window.outerWidth * 2.5; // Add pitch/yaw\n\n      x += z * Math.tan(weboji.rotation[1] + this.config.offset.yaw * Math.PI / 180) * this.config.speed.x;\n      y += z * Math.tan(weboji.rotation[0] + this.config.offset.pitch * Math.PI / 180) * this.config.speed.y - window.outerHeight; // Add offsets\n\n      x += this.config.offset.x;\n      y += this.config.offset.y; // @todo Make the sensitivity variable\n\n      this.handsfree.TweenMax.to(this.tween, 1, {\n        x: x,\n        y: y,\n        overwrite: true,\n        ease: 'linear.easeNone',\n        immediateRender: true\n      });\n      this.$pointer.style.left = \"\".concat(this.tween.x, \"px\");\n      this.$pointer.style.top = \"\".concat(this.tween.y, \"px\");\n      weboji.pointer = {\n        x: this.tween.x,\n        y: this.tween.y\n      };\n    },\n\n    /**\r\n     * Toggle pointer\r\n     */\n    onDisable: function onDisable() {\n      var _this$$pointer2;\n\n      (_this$$pointer2 = this.$pointer) === null || _this$$pointer2 === void 0 ? void 0 : _this$$pointer2.classList.add('handsfree-hidden');\n    }\n  };\n  /**\r\n   * Click on things with a gesture\r\n   */\n\n  var pluginFaceClick = {\n    models: 'weboji',\n    enabled: false,\n    tags: ['browser'],\n    config: {\n      // How often in milliseconds to trigger clicks\n      throttle: 50,\n      // Max number of frames to keep down\n      maxMouseDownedFrames: 1,\n      // Morphs to watch for and their required confidences\n      morphs: {\n        0: 0.25,\n        1: 0.25\n      }\n    },\n    // Number of frames mouse has been downed\n    mouseDowned: 0,\n    // Is the mouse up?\n    mouseUp: false,\n    // Whether one of the morph confidences have been met\n    thresholdMet: false,\n    // The last held {x, y}, used to calculate move delta\n    lastHeld: {\n      x: 0,\n      y: 0\n    },\n    // Original target under mousedown\n    $origTarget: null,\n\n    /**\r\n     * Detect click state and trigger a real click event\r\n     */\n    onFrame: function onFrame(_ref4) {\n      var _this27 = this;\n\n      var weboji = _ref4.weboji;\n      // Detect if the threshold for clicking is met with specific morphs\n      this.thresholdMet = false;\n      var event = '';\n      Object.keys(this.config.morphs).forEach(function (key) {\n        var morph = +_this27.config.morphs[key];\n        if (morph > 0 && weboji.morphs[key] >= morph) _this27.thresholdMet = true;\n      }); // Click/release and add body classes\n\n      if (this.thresholdMet) {\n        this.mouseDowned++;\n        document.body.classList.add('handsfree-clicked');\n      } else {\n        this.mouseUp = this.mouseDowned;\n        this.mouseDowned = 0;\n        document.body.classList.remove('handsfree-clicked');\n      } // Set the state\n\n\n      if (this.mouseDowned > 0 && this.mouseDowned <= this.config.maxMouseDownedFrames) event = weboji.pointer.state = 'mousedown';else if (this.mouseDowned > this.config.maxMouseDownedFrames) event = weboji.pointer.state = 'mousedrag';else if (this.mouseUp) event = weboji.pointer.state = 'mouseup';else event = 'mousemove'; // Actually click something (or focus it)\n\n      var $el = document.elementFromPoint(weboji.pointer.x, weboji.pointer.y);\n\n      if ($el && event === 'mousedown') {\n        this.$origTarget = $el;\n      }\n\n      if ($el) {\n        var eventOpts = {\n          view: window,\n          button: 0,\n          bubbles: true,\n          cancelable: true,\n          clientX: weboji.pointer.x,\n          clientY: weboji.pointer.y,\n          // Only used when the mouse is captured in full screen mode\n          movementX: weboji.pointer.x - this.lastHeld.x,\n          movementY: weboji.pointer.y - this.lastHeld.y\n        };\n        $el.dispatchEvent(new MouseEvent(event, eventOpts)); // Focus\n\n        if (weboji.pointer.state === 'mousedown' && ['INPUT', 'TEXTAREA', 'BUTTON', 'A'].includes($el.nodeName)) $el.focus(); // Click\n\n        if (weboji.pointer.state === 'mouseup' && $el === this.$origTarget) {\n          $el.dispatchEvent(new MouseEvent('click', eventOpts));\n        }\n\n        weboji.pointer.$target = $el;\n      }\n\n      this.lastHeld = weboji.pointer;\n    }\n  };\n  /**\r\n   * Scrolls the page vertically\r\n   */\n\n  var pluginFaceScroll = {\n    models: 'weboji',\n    enabled: false,\n    tags: ['browser'],\n    // Number of frames the current element is the same as the last\n    numFramesFocused: 0,\n    // The last scrollable target focused\n    $lastTarget: null,\n    // The current scrollable target\n    $target: null,\n    config: {\n      // Number of frames over the same element before activating that element\n      framesToFocus: 10,\n      vertScroll: {\n        // The multiplier to scroll by. Lower numbers are slower\n        scrollSpeed: 0.05,\n        // How many pixels from the top/bottom of the scroll area to scroll\n        scrollZone: 100\n      }\n    },\n    onUse: function onUse() {\n      this.$target = window;\n    },\n\n    /**\r\n     * Scroll the page when the cursor goes above/below the threshold\r\n     */\n    onFrame: function onFrame(_ref5) {\n      var weboji = _ref5.weboji;\n      // @FIXME we shouldn't need to do this, but this is occasionally reset to {x: 0, y: 0} when running in client mode\n      if (!weboji.pointer.x && !weboji.pointer.y) return; // Check for hover\n\n      this.checkForFocus(weboji);\n      var isScrolling = false; // Get bounds\n\n      var bounds;\n      var scrollTop = this.getTargetScrollTop();\n\n      if (this.$target.getBoundingClientRect) {\n        bounds = this.$target.getBoundingClientRect();\n      } else {\n        bounds = {\n          top: 0,\n          bottom: window.innerHeight\n        };\n      } // Check on click\n\n\n      if (weboji.pointer.state === 'mouseDown') {\n        this.numFramesFocused = 0;\n        this.maybeSetTarget(weboji);\n      } // Scroll up\n\n\n      if (weboji.pointer.y < bounds.top + this.config.vertScroll.scrollZone) {\n        this.$target.scrollTo(0, scrollTop + (weboji.pointer.y - bounds.top - this.config.vertScroll.scrollZone) * this.config.vertScroll.scrollSpeed);\n        isScrolling = true;\n      } // Scroll down\n\n\n      if (weboji.pointer.y > bounds.bottom - this.config.vertScroll.scrollZone) {\n        this.$target.scrollTo(0, scrollTop - (bounds.bottom - weboji.pointer.y - this.config.vertScroll.scrollZone) * this.config.vertScroll.scrollSpeed);\n        isScrolling = true;\n      }\n\n      isScrolling && this.maybeSelectNewTarget();\n    },\n\n    /**\r\n     * Check that the scroll is actually happening, otherwise traverse up the DOM\r\n     */\n    maybeSelectNewTarget: function maybeSelectNewTarget() {\n      var curScrollTop = this.getTargetScrollTop();\n      var didNotScroll = false; // Check if we have scrolled up\n\n      this.$target.scrollTo(0, curScrollTop + this.config.vertScroll.scrollSpeed);\n\n      if (curScrollTop === this.getTargetScrollTop()) {\n        didNotScroll = true;\n      } else {\n        this.$target.scrollTo(0, curScrollTop - this.config.vertScroll.scrollSpeed);\n        return;\n      } // Check if we have scrolled down\n\n\n      this.$target.scrollTo(0, curScrollTop - this.config.vertScroll.scrollSpeed);\n\n      if (curScrollTop === this.getTargetScrollTop()) {\n        if (didNotScroll) {\n          this.numFramesFocused = 0;\n          this.selectTarget(this.recursivelyFindScrollbar(this.$target.parentElement));\n        }\n      } else {\n        this.$target.scrollTo(0, curScrollTop + this.config.vertScroll.scrollSpeed);\n        return;\n      }\n    },\n\n    /**\r\n     * Gets the scrolltop, taking account the window object\r\n     */\n    getTargetScrollTop: function getTargetScrollTop() {\n      var _this$$target, _this$$target2;\n\n      return ((_this$$target = this.$target) === null || _this$$target === void 0 ? void 0 : _this$$target.scrollY) || ((_this$$target2 = this.$target) === null || _this$$target2 === void 0 ? void 0 : _this$$target2.scrollTop) || 0;\n    },\n\n    /**\r\n     * Checks to see if we've hovered over an element for x turns\r\n     */\n    checkForFocus: throttle_1(function (weboji) {\n      var $potTarget = document.elementFromPoint(weboji.pointer.x, weboji.pointer.y);\n      if (!$potTarget) return;\n      $potTarget = this.recursivelyFindScrollbar($potTarget);\n\n      if ($potTarget === this.$lastTarget) {\n        ++this.numFramesFocused;\n      } else {\n        this.numFramesFocused = 0;\n      }\n\n      if (this.numFramesFocused > this.config.framesToFocus) {\n        this.selectTarget($potTarget);\n      }\n\n      this.$lastTarget = $potTarget;\n    }, 100),\n\n    /**\r\n     * Select and style the element\r\n     */\n    selectTarget: function selectTarget($potTarget) {\n      // Check required in case the window is the target\n      if (this.$target.classList) {\n        this.$target.classList.remove('handsfree-scroll-focus');\n      }\n\n      if ($potTarget && $potTarget.classList) {\n        $potTarget.classList.add('handsfree-scroll-focus');\n      }\n\n      if ($potTarget.nodeName === 'HTML' || !$potTarget.nodeName) {\n        $potTarget = window;\n      }\n\n      this.$target = $potTarget;\n    },\n\n    /**\r\n     * Sets a new scroll target on click\r\n     */\n    maybeSetTarget: function maybeSetTarget(weboji) {\n      if (weboji.pointer.state === 'mouseDown' && weboji.pointer.$target) {\n        this.selectTarget(this.recursivelyFindScrollbar(weboji.pointer.$target));\n      }\n    },\n\n    /**\r\n     * Traverses up the DOM until a scrollbar is found, or until we hit the body/window\r\n     */\n    recursivelyFindScrollbar: function recursivelyFindScrollbar($target) {\n      var styles = $target && $target.getBoundingClientRect ? getComputedStyle($target) : {};\n\n      if ($target && $target.scrollHeight > $target.clientHeight && (styles.overflow === 'auto' || styles.overflow === 'auto scroll' || styles.overflowY === 'auto' || styles.overflowY === 'auto scroll')) {\n        return $target;\n      } else {\n        if ($target && $target.parentElement) {\n          return this.recursivelyFindScrollbar($target.parentElement);\n        } else {\n          return window;\n        }\n      }\n    }\n  };\n  /**\r\n   * Scrolls the page vertically by closing hand\r\n   */\n\n  var pluginPinchScroll = {\n    models: 'hands',\n    tags: ['browser'],\n    enabled: false,\n    // Number of frames the current element is the same as the last\n    numFramesFocused: [0, 0, 0, 0],\n    // The current scrollable target\n    $target: [null, null, null, null],\n    // The original grab point\n    origScrollLeft: [0, 0, 0, 0],\n    origScrollTop: [0, 0, 0, 0],\n    // The tweened scrollTop, used to smoothen out scroll\n    tweenScroll: [{\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }],\n    config: {\n      // Number of frames over the same element before activating that element\n      framesToFocus: 10,\n      // Number of pixels the middle and thumb tips must be near each other to drag\n      threshold: 50,\n      // Number of frames where a hold is not registered before releasing a drag\n      numThresholdErrorFrames: 5,\n      // Speed multiplier\n      speed: 1\n    },\n\n    /**\r\n     * Scroll the page when the cursor goes above/below the threshold\r\n     */\n    onFrame: function onFrame(_ref6) {\n      var _this28 = this;\n\n      var hands = _ref6.hands;\n      // Wait for other plugins to update\n      setTimeout(function () {\n        if (!hands.pointer) return;\n        var height = _this28.handsfree.debug.$canvas.hands.height;\n        var width = _this28.handsfree.debug.$canvas.hands.width;\n        hands.pointer.forEach(function (pointer, n) {\n          var _hands$pinchState$n, _hands$pinchState$n2; // @fixme Get rid of n > origPinch.length\n\n\n          if (!pointer.isVisible || n > hands.origPinch.length) return; // Start scroll\n\n          if (((_hands$pinchState$n = hands.pinchState[n]) === null || _hands$pinchState$n === void 0 ? void 0 : _hands$pinchState$n[0]) === 'start') {\n            var $potTarget = document.elementFromPoint(pointer.x, pointer.y);\n            _this28.$target[n] = _this28.getTarget($potTarget);\n            _this28.tweenScroll[n].x = _this28.origScrollLeft[n] = _this28.getTargetScrollLeft(_this28.$target[n]);\n            _this28.tweenScroll[n].y = _this28.origScrollTop[n] = _this28.getTargetScrollTop(_this28.$target[n]);\n\n            _this28.handsfree.TweenMax.killTweensOf(_this28.tweenScroll[n]);\n          }\n\n          if (((_hands$pinchState$n2 = hands.pinchState[n]) === null || _hands$pinchState$n2 === void 0 ? void 0 : _hands$pinchState$n2[0]) === 'held' && _this28.$target[n]) {\n            // With this one you have to pinch, drag, and release in sections each time\n            // this.handsfree.TweenMax.to(this.tweenScroll[n], 1, {\n            //   x: this.origScrollLeft[n] - (hands.origPinch[n][0].x - hands.curPinch[n][0].x) * width,\n            //   y: this.origScrollTop[n] + (hands.origPinch[n][0].y - hands.curPinch[n][0].y) * height,\n            //   overwrite: true,\n            //   ease: 'linear.easeNone',\n            //   immediateRender: true  \n            // })\n            // With this one it continuously moves based on the pinch drag distance\n            _this28.handsfree.TweenMax.to(_this28.tweenScroll[n], 1, {\n              x: _this28.tweenScroll[n].x - (hands.origPinch[n][0].x - hands.curPinch[n][0].x) * width * _this28.config.speed,\n              y: _this28.tweenScroll[n].y + (hands.origPinch[n][0].y - hands.curPinch[n][0].y) * height * _this28.config.speed,\n              overwrite: true,\n              ease: 'linear.easeNone',\n              immediateRender: true\n            });\n\n            _this28.$target[n].scrollTo(_this28.tweenScroll[n].x, _this28.tweenScroll[n].y);\n          }\n        });\n      });\n    },\n\n    /**\r\n     * Finds the closest scroll area\r\n     */\n    getTarget: function getTarget($potTarget) {\n      var styles = $potTarget && $potTarget.getBoundingClientRect ? getComputedStyle($potTarget) : {};\n\n      if ($potTarget && $potTarget.scrollHeight > $potTarget.clientHeight && (styles.overflow === 'auto' || styles.overflow === 'auto scroll' || styles.overflowY === 'auto' || styles.overflowY === 'auto scroll')) {\n        return $potTarget;\n      } else {\n        if ($potTarget && $potTarget.parentElement) {\n          return this.getTarget($potTarget.parentElement);\n        } else {\n          return window;\n        }\n      }\n    },\n\n    /**\r\n     * Gets the scrolltop, taking account the window object\r\n     */\n    getTargetScrollLeft: function getTargetScrollLeft($target) {\n      return $target.scrollX || $target.scrollLeft || 0;\n    },\n\n    /**\r\n     * Gets the scrolltop, taking account the window object\r\n     */\n    getTargetScrollTop: function getTargetScrollTop($target) {\n      return $target.scrollY || $target.scrollTop || 0;\n    }\n  };\n  var pluginPinchers = (_pluginPinchers = {\n    models: 'hands',\n    enabled: true,\n    tags: ['core'],\n    // Index of fingertips\n    fingertipIndex: [8, 12, 16, 20],\n    // Number of frames the current element is the same as the last\n    // [left, right]\n    // [index, middle, ring, pinky]\n    numFramesFocused: [[0, 0, 0, 0], [0, 0, 0, 0]],\n    // Whether the fingers are touching\n    thresholdMet: [[0, 0, 0, 0], [0, 0, 0, 0]],\n    framesSinceLastGrab: [[0, 0, 0, 0], [0, 0, 0, 0]],\n    // The original grab point for each finger\n    origPinch: [[{\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }], [{\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }]],\n    curPinch: [[{\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }], [{\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }]],\n    // Just downel\n    pinchDowned: [[0, 0, 0, 0], [0, 0, 0, 0]],\n    pinchDown: [[false, false, false, false], [false, false, false, false]],\n    pinchUp: [[false, false, false, false], [false, false, false, false]],\n    // The tweened scrollTop, used to smoothen out scroll\n    // [[leftHand], [rightHand]]\n    tween: [[{\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }], [{\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }]]\n  }, _defineProperty2(_pluginPinchers, \"numFramesFocused\", [[0, 0, 0, 0], [0, 0, 0, 0]]), _defineProperty2(_pluginPinchers, \"mouseDowned\", 0), _defineProperty2(_pluginPinchers, \"mouseUp\", false), _defineProperty2(_pluginPinchers, \"mouseThresholdMet\", false), _defineProperty2(_pluginPinchers, \"config\", {\n    // Number of frames over the same element before activating that element\n    framesToFocus: 10,\n    // Number of pixels the middle and thumb tips must be near each other to drag\n    threshold: 50,\n    // Number of frames where a hold is not registered before releasing a drag\n    numThresholdErrorFrames: 5,\n    maxMouseDownedFrames: 1\n  }), _defineProperty2(_pluginPinchers, \"onUse\", function onUse() {\n    this.$target = window;\n  }), _defineProperty2(_pluginPinchers, \"onFrame\", function onFrame(_ref7) {\n    var hands = _ref7.hands;\n    if (!hands.multiHandLandmarks) return;\n    var height = this.handsfree.debug.$canvas.hands.height;\n    var leftVisible = hands.multiHandedness.some(function (hand) {\n      return hand.label === 'Right';\n    });\n    var rightVisible = hands.multiHandedness.some(function (hand) {\n      return hand.label === 'Left';\n    }); // Detect if the threshold for clicking is met with specific morphs\n\n    for (var n = 0; n < hands.multiHandLandmarks.length; n++) {\n      // Set the hand index\n      var hand = hands.multiHandedness[n].label === 'Right' ? 0 : 1;\n\n      for (var finger = 0; finger < 4; finger++) {\n        // Check if fingers are touching\n        var a = hands.multiHandLandmarks[n][4].x - hands.multiHandLandmarks[n][this.fingertipIndex[finger]].x;\n        var b = hands.multiHandLandmarks[n][4].y - hands.multiHandLandmarks[n][this.fingertipIndex[finger]].y;\n        var c = Math.sqrt(a * a + b * b) * height;\n        var thresholdMet = this.thresholdMet[hand][finger] = c < this.config.threshold;\n\n        if (thresholdMet) {\n          // Set the current pinch\n          this.curPinch[hand][finger] = hands.multiHandLandmarks[n][4]; // Store the original pinch\n\n          if (this.framesSinceLastGrab[hand][finger] > this.config.numThresholdErrorFrames) {\n            this.origPinch[hand][finger] = hands.multiHandLandmarks[n][4];\n            this.handsfree.TweenMax.killTweensOf(this.tween[hand][finger]);\n          }\n\n          this.framesSinceLastGrab[hand][finger] = 0;\n        }\n\n        ++this.framesSinceLastGrab[hand][finger];\n      }\n    } // Update the hands object\n\n\n    hands.origPinch = this.origPinch;\n    hands.curPinch = this.curPinch;\n    this.handsfree.data.hands = this.getPinchStates(hands, leftVisible, rightVisible);\n  }), _defineProperty2(_pluginPinchers, \"getPinchStates\", function getPinchStates(hands, leftVisible, rightVisible) {\n    var visible = [leftVisible, rightVisible]; // Make sure states are available\n\n    hands.pinchState = [['', '', '', ''], ['', '', '', '']]; // Loop through every hand and finger\n\n    for (var hand = 0; hand < 2; hand++) {\n      for (var finger = 0; finger < 4; finger++) {\n        // Click\n        if (visible[hand] && this.thresholdMet[hand][finger]) {\n          this.pinchDowned[hand][finger]++;\n          document.body.classList.add(\"handsfree-finger-pinched-\".concat(hand, \"-\").concat(finger), \"handsfree-finger-pinched-\".concat(finger));\n        } else {\n          this.pinchUp[hand][finger] = this.pinchDowned[hand][finger];\n          this.pinchDowned[hand][finger] = 0;\n          document.body.classList.remove(\"handsfree-finger-pinched-\".concat(hand, \"-\").concat(finger), \"handsfree-finger-pinched-\".concat(finger));\n        } // Set the state\n\n\n        if (this.pinchDowned[hand][finger] > 0 && this.pinchDowned[hand][finger] <= this.config.maxMouseDownedFrames) {\n          hands.pinchState[hand][finger] = 'start';\n        } else if (this.pinchDowned[hand][finger] > this.config.maxMouseDownedFrames) {\n          hands.pinchState[hand][finger] = 'held';\n        } else if (this.pinchUp[hand][finger]) {\n          hands.pinchState[hand][finger] = 'released';\n        } else {\n          hands.pinchState[hand][finger] = '';\n        } // Emit an event\n\n\n        if (hands.pinchState[hand][finger]) {\n          // Specific hand\n          this.handsfree.emit(\"finger-pinched-\".concat(hand, \"-\").concat(finger), {\n            event: hands.pinchState[hand][finger],\n            origPinch: hands.origPinch[hand][finger],\n            curPinch: hands.curPinch[hand][finger]\n          });\n          this.handsfree.emit(\"finger-pinched-\".concat(hands.pinchState[hand][finger], \"-\").concat(hand, \"-\").concat(finger), {\n            event: hands.pinchState[hand][finger],\n            origPinch: hands.origPinch[hand][finger],\n            curPinch: hands.curPinch[hand][finger]\n          }); // Any hand\n\n          this.handsfree.emit(\"finger-pinched-\".concat(finger), {\n            event: hands.pinchState[hand][finger],\n            origPinch: hands.origPinch[hand][finger],\n            curPinch: hands.curPinch[hand][finger]\n          });\n          this.handsfree.emit(\"finger-pinched-\".concat(hands.pinchState[hand][finger], \"-\").concat(finger), {\n            event: hands.pinchState[hand][finger],\n            origPinch: hands.origPinch[hand][finger],\n            curPinch: hands.curPinch[hand][finger]\n          });\n        }\n      }\n    }\n\n    return hands;\n  }), _pluginPinchers); // Maps handsfree pincher events to \n\n  var eventMap = {\n    start: 'mousedown',\n    held: 'mousemove',\n    released: 'mouseup'\n  }; // The last pointer positions for each hand, used to determine movement over time\n\n  var lastHeld = [{\n    x: 0,\n    y: 0\n  }, {\n    x: 0,\n    y: 0\n  }, {\n    x: 0,\n    y: 0\n  }, {\n    x: 0,\n    y: 0\n  }];\n  /**\r\n   * Move a pointer with your palm\r\n   */\n\n  var pluginPalmPointers = (_pluginPalmPointers = {\n    models: 'hands',\n    tags: ['browser'],\n    enabled: false,\n    // The pointer element\n    $pointer: [],\n    arePointersVisible: true,\n    // Pointers position\n    pointer: [{\n      x: -20,\n      y: -20,\n      isVisible: false\n    }, {\n      x: -20,\n      y: -20,\n      isVisible: false\n    }, {\n      x: -20,\n      y: -20,\n      isVisible: false\n    }, {\n      x: -20,\n      y: -20,\n      isVisible: false\n    }],\n    // Used to smoothen out the pointer\n    tween: [{\n      x: -20,\n      y: -20\n    }, {\n      x: -20,\n      y: -20\n    }, {\n      x: -20,\n      y: -20\n    }, {\n      x: -20,\n      y: -20\n    }],\n    config: {\n      offset: {\n        x: 0,\n        y: 0\n      },\n      speed: {\n        x: 1,\n        y: 1\n      }\n    },\n\n    /**\r\n     * Create and toggle pointers\r\n     */\n    onUse: function onUse() {\n      for (var i = 0; i < 4; i++) {\n        var $pointer = document.createElement('div');\n        $pointer.classList.add('handsfree-pointer', 'handsfree-pointer-palm', 'handsfree-hide-when-started-without-hands');\n        document.body.appendChild($pointer);\n        this.$pointer[i] = $pointer;\n      }\n\n      if (this.enabled && this.arePointersVisible) {\n        this.showPointers();\n      } else {\n        this.hidePointers();\n      }\n    },\n\n    /**\r\n     * Show pointers on enable\r\n     */\n    onEnable: function onEnable() {\n      var arePointersVisible = this.arePointersVisible;\n      this.showPointers();\n      this.arePointersVisible = arePointersVisible;\n    },\n\n    /**\r\n     * Hide pointers on disable\r\n     */\n    onDisable: function onDisable() {\n      var arePointersVisible = this.arePointersVisible;\n      this.hidePointers();\n      this.arePointersVisible = arePointersVisible;\n    },\n\n    /**\r\n     * Positions the pointer and dispatches events\r\n     */\n    onFrame: function onFrame(_ref8) {\n      var _this29 = this;\n\n      var hands = _ref8.hands;\n\n      // Hide pointers\n      if (!(hands !== null && hands !== void 0 && hands.multiHandLandmarks)) {\n        this.$pointer.forEach(function ($pointer) {\n          return $pointer.style.display = 'none';\n        });\n        return;\n      }\n\n      hands.pointer = [{\n        isVisible: false\n      }, {\n        isVisible: false\n      }, {\n        isVisible: false\n      }, {\n        isVisible: false\n      }];\n      hands.multiHandLandmarks.forEach(function (landmarks, n) {\n        var _pointer$pinchState, _pointer$pinchState$n;\n\n        var pointer = hands.pointer[n]; // Use the correct hand index\n\n        var hand;\n\n        if (n < 2) {\n          hand = hands.multiHandedness[n].label === 'Right' ? 0 : 1;\n        } else {\n          hand = hands.multiHandedness[n].label === 'Right' ? 2 : 3;\n        } // Update pointer position\n\n\n        _this29.handsfree.TweenMax.to(_this29.tween[hand], 1, {\n          x: window.outerWidth * _this29.config.speed.x - window.outerWidth * _this29.config.speed.x / 2 + window.outerWidth / 2 - hands.multiHandLandmarks[n][21].x * _this29.config.speed.x * window.outerWidth + _this29.config.offset.x,\n          y: hands.multiHandLandmarks[n][21].y * window.outerHeight * _this29.config.speed.y - window.outerHeight * _this29.config.speed.y / 2 + window.outerHeight / 2 + _this29.config.offset.y,\n          overwrite: true,\n          ease: 'linear.easeNone',\n          immediate: true\n        });\n\n        hands.pointer[hand] = {\n          x: _this29.tween[hand].x,\n          y: _this29.tween[hand].y,\n          isVisible: true\n        }; // Visually update pointer element\n\n        _this29.$pointer[hand].style.left = \"\".concat(_this29.tween[hand].x, \"px\");\n        _this29.$pointer[hand].style.top = \"\".concat(_this29.tween[hand].y, \"px\"); // Dispatch events\n\n        var event = pointer === null || pointer === void 0 ? void 0 : (_pointer$pinchState = pointer.pinchState) === null || _pointer$pinchState === void 0 ? void 0 : (_pointer$pinchState$n = _pointer$pinchState[n]) === null || _pointer$pinchState$n === void 0 ? void 0 : _pointer$pinchState$n[0];\n\n        if (event && pointer.isVisible) {\n          // Get the event and element to send events to\n          event = eventMap[event];\n          var $el = document.elementFromPoint(pointer.x, pointer.y); // Dispatch the event\n\n          if ($el) {\n            $el.dispatchEvent(new MouseEvent(event, {\n              view: window,\n              button: 0,\n              bubbles: true,\n              cancelable: true,\n              clientX: pointer.x,\n              clientY: pointer.y,\n              // Only used when the mouse is captured in full screen mode\n              movementX: pointer.x - lastHeld[hand].x,\n              movementY: pointer.y - lastHeld[hand].y\n            }));\n          }\n\n          lastHeld[hand] = pointer;\n        }\n      }); // Toggle pointers\n\n      hands.pointer.forEach(function (pointer, hand) {\n        if (pointer.isVisible) {\n          _this29.$pointer[hand].style.display = 'block';\n        } else {\n          _this29.$pointer[hand].style.display = 'none';\n        }\n      });\n    }\n  }, _defineProperty2(_pluginPalmPointers, \"onDisable\", function onDisable() {\n    this.$pointer.forEach(function ($pointer) {\n      $pointer.classList.add('handsfree-hidden');\n    });\n  }), _defineProperty2(_pluginPalmPointers, \"showPointers\", function showPointers() {\n    this.arePointersVisible = true;\n\n    for (var i = 0; i < 4; i++) {\n      this.$pointer[i].classList.remove('handsfree-hidden');\n    }\n  }), _defineProperty2(_pluginPalmPointers, \"hidePointers\", function hidePointers() {\n    this.arePointersVisible = false;\n\n    for (var i = 0; i < 4; i++) {\n      this.$pointer[i].classList.add('handsfree-hidden');\n    }\n  }), _pluginPalmPointers);\n  /*\r\n            \r\n            (\\.   \\      ,/)\r\n              \\(   |\\     )/\r\n              //\\  | \\   /\\\\\r\n            (/ /\\_#oo#_/\\ \\)\r\n              \\/\\  ####  /\\/\r\n                  \\`##'\r\n  \r\n             Presenting \r\n                  Handsfree.js\r\n                  8.5.1\r\n      Docs:       https://handsfree.js.org\r\n    Repo:       https://github.com/midiblocks/handsfree\r\n    Discord:    https://discord.gg/JeevWjTEdu\r\n    Newsletter: http://eepurl.com/hhD7S1\r\n      /////////////////////////////////////////////////////////////\r\n    ///////////////////// Table of Contents /////////////////////\r\n    /////////////////////////////////////////////////////////////\r\n      Use \"CTRL+F + #n\" to hop around in this file\r\n    \r\n    #1 Setup\r\n    #2 Loop\r\n    #3 Plugins\r\n    #4 Gestures\r\n    #5 Events\r\n    #6 Helpers\r\n    #7 Debugger\r\n    */\n\n  var corePlugins = {\n    facePointer: pluginFacePointer,\n    faceClick: pluginFaceClick,\n    faceScroll: pluginFaceScroll,\n    pinchScroll: pluginPinchScroll,\n    pinchers: pluginPinchers,\n    palmPointers: pluginPalmPointers\n  };\n  /* ////////////////////////// #1 SETUP /////////////////////////\r\n                      \r\n                   \r\n                           \r\n                            \r\n                           \r\n                             \r\n    ///////////////////////////////////////////////////////////// */\n  // Used to separate video, canvas, etc ID's\n\n  var id = 0;\n  /**\r\n   * The Handsfree class\r\n   */\n\n  var Handsfree = /*#__PURE__*/function () {\n    /**\r\n     * Let's do this \r\n     * @see https://handsfree.js.org/ref/prop/config\r\n     * \r\n     * @param {Object} config The initial config to use\r\n     */\n    function Handsfree() {\n      var _this30 = this;\n\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, Handsfree);\n\n      // Helpers\n      this.throttle = throttle_1;\n      this.TweenMax = TweenMax; // Assign the instance ID\n\n      this.id = ++id;\n      this.version = '8.5.1';\n      this.data = {}; // Dependency management\n\n      this.dependencies = {\n        loading: [],\n        loaded: []\n      }; // List of mediapipe models (by name) that are warming up\n\n      this.mediapipeWarmups = {\n        isWarmingUp: false,\n        hands: false,\n        pose: false,\n        facemesh: false\n      }; // Plugins\n\n      this.plugin = {};\n      this.taggedPlugins = {\n        untagged: []\n      }; // Gestures\n\n      this.gesture = {};\n      this.taggedGestures = {\n        untagged: []\n      }; // Clean config and set defaults\n\n      this.config = this.cleanConfig(config); // Setup\n\n      this.setupDebugger();\n      this.prepareModels();\n      this.loadCorePlugins(); // Start tracking when all models are loaded\n\n      this.hasAddedBodyClass = false;\n      this.isUpdating = false;\n      this.numModelsLoaded = 0;\n      this.on('modelReady', function () {\n        var numActiveModels = 0;\n        Object.keys(_this30.model).forEach(function (modelName) {\n          _this30.model[modelName].enabled && ++numActiveModels;\n        });\n\n        if (++_this30.numModelsLoaded === numActiveModels) {\n          document.body.classList.remove('handsfree-loading');\n          document.body.classList.add('handsfree-started');\n          _this30.hasAddedBodyClass = true;\n\n          if (!_this30.config.isClient && (!_this30.isUpdating || _this30.isUpdating && _this30.config.autostart)) {\n            _this30.isLooping = true;\n\n            _this30.loop();\n          }\n        }\n      });\n      this.emit('init', this);\n    }\n    /**\r\n     * Prepares the models\r\n     */\n\n\n    _createClass(Handsfree, [{\n      key: \"prepareModels\",\n      value: function prepareModels() {\n        this.model = {\n          weboji: {},\n          hands: {},\n          facemesh: {},\n          pose: {},\n          handpose: {}\n        };\n        this.model.weboji = new WebojiModel(this, this.config.weboji);\n        this.model.hands = new HandsModel(this, this.config.hands);\n        this.model.pose = new PoseModel(this, this.config.pose);\n        this.model.facemesh = new FacemeshModel(this, this.config.facemesh);\n        this.model.handpose = new HandposeModel(this, this.config.handpose);\n      }\n      /**\r\n       * Cleans and sanitizes the config, setting up defaults\r\n       * @see https://handsfree.js.org/ref/method/cleanConfig\r\n       * \r\n       * @param config {Object} The config object to use\r\n       * @param defaults {Object} (Optional) The defaults to use.\r\n       *    If null, then the original Handsfree.js defaults will be used\r\n       * \r\n       * @returns {Object} The cleaned config\r\n       */\n\n    }, {\n      key: \"cleanConfig\",\n      value: function cleanConfig(config, defaults) {\n        // Set default\n        if (!defaults) defaults = Object.assign({}, defaultConfig);\n        defaults.setup.wrap.$parent = document.body; // Map model booleans to objects\n\n        if (typeof config.weboji === 'boolean') {\n          config.weboji = {\n            enabled: config.weboji\n          };\n        }\n\n        if (typeof config.hands === 'boolean') {\n          config.hands = {\n            enabled: config.hands\n          };\n        }\n\n        if (typeof config.facemesh === 'boolean') {\n          config.facemesh = {\n            enabled: config.facemesh\n          };\n        }\n\n        if (typeof config.pose === 'boolean') {\n          config.pose = {\n            enabled: config.pose\n          };\n        }\n\n        if (typeof config.handpose === 'boolean') {\n          config.handpose = {\n            enabled: config.handpose\n          };\n        } // Map plugin booleans to objects\n\n\n        config.plugin && Object.keys(config.plugin).forEach(function (plugin) {\n          if (typeof config.plugin[plugin] === 'boolean') {\n            config.plugin[plugin] = {\n              enabled: config.plugin[plugin]\n            };\n          }\n        }); // Map gesture booleans to objects\n\n        config.gesture && Object.keys(config.gesture).forEach(function (gesture) {\n          if (typeof config.gesture[gesture] === 'boolean') {\n            config.gesture[gesture] = {\n              enabled: config.gesture[gesture]\n            };\n          }\n        });\n        return merge_1({}, defaults, config);\n      }\n      /**\r\n       * Updates the instance, loading required dependencies\r\n       * @see https://handsfree.js.org./ref/method/update\r\n       * \r\n       * @param {Object} config The changes to apply\r\n       * @param {Function} callback Called after\r\n       */\n\n    }, {\n      key: \"update\",\n      value: function update(config, callback) {\n        var _this31 = this;\n\n        this.config = this.cleanConfig(config, this.config);\n        this.isUpdating = true; // Update video\n\n        this.isUsingWebcam = !this.config.setup.video.$el.currentSrc;\n        this.debug.$video = this.config.setup.video.$el;\n        this.debug.$video.width = this.config.setup.video.width;\n        this.debug.$video.height = this.config.setup.video.height // Run enable/disable methods on changed models\n        ;\n        ['hands', 'facemesh', 'pose', 'handpose', 'weboji'].forEach(function (model) {\n          var wasEnabled = _this31.model[model].enabled;\n          _this31.config[model] = _this31.model[model].config = merge_1({}, _this31.model[model].config, config[model]);\n          if (wasEnabled && !_this31.config[model].enabled) _this31.model[model].disable();else if (!wasEnabled && _this31.config[model].enabled) _this31.model[model].enable(false);\n        }); // Enable plugins\n\n        config.plugin && Object.keys(config.plugin).forEach(function (plugin) {\n          if (typeof config.plugin[plugin].enabled === 'boolean') {\n            if (config.plugin[plugin].enabled) {\n              _this31.plugin[plugin].enable();\n            } else {\n              _this31.plugin[plugin].disable();\n            }\n          }\n        }); // Enable gestures\n\n        config.gesture && Object.keys(config.gesture).forEach(function (gesture) {\n          if (typeof config.gesture[gesture].enabled === 'boolean') {\n            if (config.gesture[gesture].enabled) {\n              _this31.gesture[gesture].enable();\n            } else {\n              _this31.gesture[gesture].disable();\n            }\n          }\n        }); // Start\n\n        if (!this.config.isClient && this.config.autostart) {\n          this.start(callback);\n        } else {\n          callback && callback();\n        }\n      }\n      /* /////////////////////////// #2 LOOP /////////////////////////\r\n      \r\n                                  \r\n                             \r\n                                   \r\n                                    \r\n                             \r\n                                 \r\n        \r\n      /////////////////////////////////////////////////////////////// */\n\n      /**\r\n       * Starts the trackers\r\n       * @see https://handsfree.js.org/ref/method/start\r\n       * \r\n       * @param {Function} callback The callback to run before the very first frame\r\n       */\n\n    }, {\n      key: \"start\",\n      value: function start(callback) {\n        var _this32 = this;\n\n        // Cleans any configs since instantiation (particularly for boolean-ly set plugins)\n        this.config = this.cleanConfig(this.config, this.config);\n        this.isUpdating = false; // Start loading\n\n        document.body.classList.add('handsfree-loading');\n        this.emit('loading', this); // Call the callback once things are loaded\n\n        if (callback) {\n          this.on('modelReady', callback, {\n            once: true\n          });\n        } // Load dependencies\n\n\n        this.numModelsLoaded = 0;\n        Object.keys(this.model).forEach(function (modelName) {\n          var model = _this32.model[modelName];\n\n          if (model.enabled && !model.dependenciesLoaded) {\n            model.loadDependencies();\n          } else if (model.enabled) {\n            _this32.emit('modelReady', model);\n\n            _this32.emit(\"\".concat(modelName, \"ModelReady\"), model);\n          }\n        }); // Enable initial plugins\n\n        Object.keys(this.config.plugin).forEach(function (plugin) {\n          var _this$config$plugin, _this$config$plugin$p;\n\n          if (typeof ((_this$config$plugin = _this32.config.plugin) === null || _this$config$plugin === void 0 ? void 0 : (_this$config$plugin$p = _this$config$plugin[plugin]) === null || _this$config$plugin$p === void 0 ? void 0 : _this$config$plugin$p.enabled) === 'boolean' && _this32.config.plugin[plugin].enabled) {\n            _this32.plugin[plugin].enable();\n          }\n        }); // Enable initial gestures\n\n        Object.keys(this.config.gesture).forEach(function (gesture) {\n          var _this$config$gesture, _this$config$gesture$;\n\n          if (typeof ((_this$config$gesture = _this32.config.gesture) === null || _this$config$gesture === void 0 ? void 0 : (_this$config$gesture$ = _this$config$gesture[gesture]) === null || _this$config$gesture$ === void 0 ? void 0 : _this$config$gesture$.enabled) === 'boolean' && _this32.config.gesture[gesture].enabled) {\n            _this32.gesture[gesture].enable();\n          }\n        });\n      }\n      /**\r\n       * Stops tracking\r\n       * - Currently this just stops the tracker\r\n       * \r\n       * @see https://handsfree.js.org/ref/method/stop\r\n       */\n\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        location.reload();\n      }\n      /**\r\n       * Pauses inference to free up resources but maintains the\r\n       * webcam stream so that it can be unpaused instantly\r\n       * \r\n       * @see https://handsfree.js.org/ref/method/pause\r\n       */\n\n    }, {\n      key: \"pause\",\n      value: function pause() {\n        this.isLooping = false;\n      }\n      /**\r\n       * Resumes the loop from an unpaused state\r\n       * \r\n       * @see https://handsfree.js.org/ref/method/pause\r\n       */\n\n    }, {\n      key: \"unpause\",\n      value: function unpause() {\n        if (!this.isLooping) {\n          this.isLooping = true;\n          this.loop();\n        }\n      }\n      /**\r\n       * Called on every webcam frame\r\n       * @see https://handsfree.js.org/ref/method/loop\r\n       */\n\n    }, {\n      key: \"loop\",\n      value: function loop() {\n        var _this33 = this;\n\n        var _this$taggedPlugins$u; // Get model data\n\n\n        Object.keys(this.model).forEach(function (modelName) {\n          var model = _this33.model[modelName];\n\n          if (model.enabled && model.dependenciesLoaded) {\n            model.getData();\n          }\n        }); // Emit data\n\n        this.emit('data', this.data); // Run untagged plugins\n\n        (_this$taggedPlugins$u = this.taggedPlugins.untagged) === null || _this$taggedPlugins$u === void 0 ? void 0 : _this$taggedPlugins$u.forEach(function (pluginName) {\n          var _this$plugin$pluginNa;\n\n          _this33.plugin[pluginName].enabled && ((_this$plugin$pluginNa = _this33.plugin[pluginName]) === null || _this$plugin$pluginNa === void 0 ? void 0 : _this$plugin$pluginNa.onFrame(_this33.data));\n        }); // Render video behind everything else\n        // - Note: Weboji uses its own camera\n\n        if (this.isDebugging) {\n          var isUsingCamera = ['hands', 'pose', 'handpose', 'facemesh'].find(function (model) {\n            if (_this33.model[model].enabled) {\n              return model;\n            }\n          });\n\n          if (isUsingCamera) {\n            this.debug.context.video.drawImage(this.debug.$video, 0, 0, this.debug.$canvas.video.width, this.debug.$canvas.video.height);\n          }\n        }\n\n        this.isLooping && requestAnimationFrame(function () {\n          return _this33.isLooping && _this33.loop();\n        });\n      }\n      /* //////////////////////// #3 PLUGINS /////////////////////////\r\n      \r\n                          \r\n                       \r\n                       \r\n                        \r\n                  \r\n                       \r\n      \r\n        /////////////////////////////////////////////////////////////*/\n\n      /**\r\n       * Adds a callback (we call it a plugin) to be called after every tracked frame\r\n       * @see https://handsfree.js.org/ref/method/use\r\n       *\r\n       * @param {String} name The plugin name\r\n       * @param {Object|Function} config The config object, or a callback to run on every fram\r\n       * @returns {Plugin} The plugin object\r\n       */\n\n    }, {\n      key: \"use\",\n      value: function use(name, config) {\n        var _this34 = this;\n\n        // Make sure we have an options object\n        if (typeof config === 'function') {\n          config = {\n            onFrame: config\n          };\n        }\n\n        config = merge_1({}, {\n          // Stores the plugins name for internal use\n          name: name,\n          // The model to apply this plugin to\n          models: [],\n          // Plugin tags for quickly turning things on/off\n          tags: [],\n          // Whether the plugin is enabled by default\n          enabled: true,\n          // A set of default config values the user can override during instanciation\n          config: {},\n          // (instance) => Called on every frame. The callback is mapped to this\n          onFrame: null,\n          // (instance) => Called when the plugin is first used\n          onUse: null,\n          // (instance) => Called when the plugin is enabled\n          onEnable: null,\n          // (instance) => Called when the plugin is disabled\n          onDisable: null\n        }, config); // Sanitize\n\n        if (typeof config.models === 'string') {\n          config.models = [config.models];\n        } // Setup plugin tags\n\n\n        if (typeof config.tags === 'string') {\n          config.tags = [config.tags];\n        }\n\n        config.tags.forEach(function (tag) {\n          if (!_this34.taggedPlugins[tag]) _this34.taggedPlugins[tag] = [];\n\n          _this34.taggedPlugins[tag].push(name);\n        }); // Create the plugin\n\n        this.plugin[name] = new Plugin(config, this);\n        this.plugin[name].onUse && this.plugin[name].onUse(); // Store a reference to the plugin to simplify things\n\n        if (config.models.length) {\n          config.models.forEach(function (modelName) {\n            _this34.model[modelName].plugins.push(name);\n          });\n        } else {\n          this.taggedPlugins.untagged.push(name);\n        }\n\n        return this.plugin[name];\n      }\n      /**\r\n       * Enable plugins by tags\r\n       * @see https://handsfree.js.org/ref/method/enablePlugins\r\n       * \r\n       * @param {string|object} tags (Optional) The plugins with tags to enable. Enables all if null\r\n       */\n\n    }, {\n      key: \"enablePlugins\",\n      value: function enablePlugins(tags) {\n        var _this35 = this;\n\n        // Sanitize\n        if (typeof tags === 'string') tags = [tags];\n        if (!tags) tags = Object.keys(this.taggedPlugins);\n        tags.forEach(function (tag) {\n          _this35.taggedPlugins[tag].forEach(function (pluginName) {\n            _this35.plugin[pluginName].enable();\n          });\n        });\n      }\n      /**\r\n       * Disable plugins by tags\r\n       * @see https://handsfree.js.org/ref/method/disablePlugins\r\n       * \r\n       * @param {string|object} tags (Optional) The plugins with tags to disable. Disables all if null\r\n       */\n\n    }, {\n      key: \"disablePlugins\",\n      value: function disablePlugins(tags) {\n        var _this36 = this;\n\n        // Sanitize\n        if (typeof tags === 'string') tags = [tags];\n        if (!tags) tags = Object.keys(this.taggedPlugins);\n        tags.forEach(function (tag) {\n          _this36.taggedPlugins[tag].forEach(function (pluginName) {\n            _this36.plugin[pluginName].disable();\n          });\n        });\n      }\n      /**\r\n       * Run plugins manually\r\n       * @param {Object} data The data to run\r\n       */\n\n    }, {\n      key: \"runPlugins\",\n      value: function runPlugins(data) {\n        var _this37 = this;\n\n        var _this$taggedPlugins$u2;\n\n        this.data = data; // Add start class to body\n\n        if (this.config.isClient && !this.hasAddedBodyClass) {\n          document.body.classList.add('handsfree-started');\n          this.hasAddedBodyClass = true;\n        } // Run model plugins\n\n\n        Object.keys(this.model).forEach(function (name) {\n          _this37.model[name].data = data === null || data === void 0 ? void 0 : data[name];\n\n          _this37.model[name].runPlugins();\n        }); // Run untagged plugins\n\n        (_this$taggedPlugins$u2 = this.taggedPlugins.untagged) === null || _this$taggedPlugins$u2 === void 0 ? void 0 : _this$taggedPlugins$u2.forEach(function (pluginName) {\n          var _this$plugin$pluginNa2;\n\n          _this37.plugin[pluginName].enabled && ((_this$plugin$pluginNa2 = _this37.plugin[pluginName]) === null || _this$plugin$pluginNa2 === void 0 ? void 0 : _this$plugin$pluginNa2.onFrame(_this37.data));\n        });\n      }\n      /* //////////////////////// #4 GESTURES /////////////////////////\r\n      \r\n            \r\n          \r\n                     \r\n                      \r\n              \r\n                  \r\n                                                                         \r\n        /////////////////////////////////////////////////////////////*/\n\n      /**\r\n       * Adds a callback to be called whenever a gesture is detected\r\n       * @see https://handsfree.js.org/ref/method/useGesture\r\n       * \r\n       * @param {Object} config The config object\r\n       * @returns {Gesture} The gesture object\r\n       */\n\n    }, {\n      key: \"useGesture\",\n      value: function useGesture(config) {\n        var _this38 = this;\n\n        config = merge_1({}, {\n          // Stores the gestures name for internal use\n          name: 'untitled',\n          // The description\n          description: [],\n          // The model this gesture works with\n          models: [],\n          // Gesture tags for quickly turning them on/off\n          tags: [],\n          // Whether the gesture is enabled or not\n          enabled: true\n        }, config); // Sanitize\n\n        if (typeof config.models === 'string') {\n          config.models = [config.models];\n        } // Setup gesture tags\n\n\n        if (typeof config.tags === 'string') {\n          config.tags = [config.tags];\n        }\n\n        config.tags.forEach(function (tag) {\n          if (!_this38.taggedGestures[tag]) _this38.taggedGestures[tag] = [];\n\n          _this38.taggedGestures[tag].push(config.name);\n        }); // Create the gesture\n\n        switch (config.algorithm) {\n          case 'fingerpose':\n            this.gesture[config.name] = new GestureFingerpose(config, this);\n            break;\n        } // Store a reference to the gesture to simplify things\n\n\n        if (config.models.length) {\n          config.models.forEach(function (modelName) {\n            _this38.model[modelName].gestures.push(config.name);\n\n            _this38.model[modelName].updateGestureEstimator();\n          });\n        } else {\n          this.taggedGestures.untagged.push(config.name);\n        }\n\n        return this.gesture[config.name];\n      }\n      /**\r\n       * Enable gestures by tags\r\n       * @see https://handsfree.js.org/ref/method/enableGestures\r\n       * \r\n       * @param {string|object} tags (Optional) The gestures with tags to enable. Enables all if null\r\n       */\n\n    }, {\n      key: \"enableGestures\",\n      value: function enableGestures(tags) {\n        var _this39 = this;\n\n        // Sanitize\n        if (typeof tags === 'string') tags = [tags];\n        if (!tags) tags = Object.keys(this.taggedGestures);\n        tags.forEach(function (tag) {\n          _this39.taggedGestures[tag].forEach(function (gestureName) {\n            _this39.gesture[gestureName].enable();\n          });\n        });\n      }\n      /**\r\n       * Disable Gestures by tags\r\n       * @see https://handsfree.js.org/ref/method/disableGestures\r\n       * \r\n       * @param {string|object} tags (Optional) The Gestures with tags to disable. Disables all if null\r\n       */\n\n    }, {\n      key: \"disableGestures\",\n      value: function disableGestures(tags) {\n        var _this40 = this;\n\n        // Sanitize\n        if (typeof tags === 'string') tags = [tags];\n        if (!tags) tags = Object.keys(this.taggedGestures);\n        tags.forEach(function (tag) {\n          _this40.taggedGestures[tag].forEach(function (gestureName) {\n            _this40.gesture[gestureName].disable();\n          });\n        });\n      }\n      /* ///////////////////////// #5 EVENTS /////////////////////////\r\n      \r\n                  \r\n                 \r\n                          \r\n                       \r\n                     \r\n                        \r\n                                                          \r\n      ///////////////////////////////////////////////////////////// */\n\n      /**\r\n       * Triggers a document event with `handsfree-${eventName}`\r\n       * @see https://handsfree.js.org/ref/method/emit\r\n       * \r\n       * @param {String} eventName The name of the event\r\n       * @param {*} detail (optional) Data to send with the event\r\n       */\n\n    }, {\n      key: \"emit\",\n      value: function emit(eventName) {\n        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var event = new CustomEvent(\"handsfree-\".concat(eventName), {\n          detail: detail\n        });\n        document.dispatchEvent(event);\n      }\n      /**\r\n       * Calls a callback on `document` when an event is triggered\r\n       * @see https://handsfree.js.org/ref/method/on\r\n       *\r\n       * @param {String} eventName The `handsfree-${eventName}` to listen to\r\n       * @param {Function} callback The callback to call\r\n       * @param {Object} opts The options to pass into addEventListener (eg: {once: true})\r\n       */\n\n    }, {\n      key: \"on\",\n      value: function on(eventName, callback, opts) {\n        document.addEventListener(\"handsfree-\".concat(eventName), function (ev) {\n          callback(ev.detail);\n        }, opts);\n      }\n      /* //////////////////////// #6 HELPERS /////////////////////////\r\n      \r\n                   \r\n                 \r\n                   \r\n                    \r\n                   \r\n                   \r\n                                                                    \r\n        /////////////////////////////////////////////////////////////*/\n\n      /**\r\n       * Helper to normalze a value within a max range\r\n       * @see https://handsfree.js.org/ref/method/normalize\r\n       * \r\n       * @param {Number} value The value to normalize\r\n       * @param {Number} max The maximum value to normalize to, or the upper bound\r\n       * @param {Number} min The minimum value to normalize to, or the lower bound\r\n       */\n\n    }, {\n      key: \"normalize\",\n      value: function normalize(value, max) {\n        var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        return (value - min) / (max - min);\n      }\n      /**\r\n       * Gets the webcam media stream into handsfree.debug.$video\r\n       * @see https://handsfree.js.org/ref/method/getUserMedia\r\n       * \r\n       * @param {Object} callback The callback to call after the stream is received\r\n       */\n\n    }, {\n      key: \"getUserMedia\",\n      value: function getUserMedia(callback) {\n        var _this41 = this;\n\n        // Start getting the stream and call callback after\n        if (!this.debug.stream && !this.debug.isGettingStream) {\n          var _this$model$weboji, _this$model$weboji$ap; // Use the weboji stream if already active\n\n\n          if (this.isUsingWebcam && (_this$model$weboji = this.model.weboji) !== null && _this$model$weboji !== void 0 && (_this$model$weboji$ap = _this$model$weboji.api) !== null && _this$model$weboji$ap !== void 0 && _this$model$weboji$ap.get_videoStream) {\n            this.debug.$video = this.model.weboji.api.get_video();\n            this.debug.$video.srcObject = this.debug.stream = this.model.weboji.api.get_videoStream();\n            this.emit('gotUserMedia', this.debug.stream);\n            callback && callback(); // Get or create a new media stream\n          } else {\n            // Create a media stream (webcam)\n            if (this.isUsingWebcam) {\n              this.debug.isGettingStream = true;\n              navigator.mediaDevices.getUserMedia({\n                audio: false,\n                video: {\n                  facingMode: 'user',\n                  width: this.debug.$video.width,\n                  height: this.debug.$video.height\n                }\n              }).then(function (stream) {\n                _this41.debug.$video.srcObject = _this41.debug.stream = stream;\n\n                _this41.debug.$video.onloadedmetadata = function () {\n                  _this41.debug.$video.play();\n\n                  _this41.emit('gotUserMedia', stream);\n\n                  callback && callback();\n                };\n              }).catch(function (err) {\n                console.error(\"Error getting user media: \".concat(err));\n              }).finally(function () {\n                _this41.debug.isGettingStream = false;\n              }); // Use a video source\n            } else {\n              this.debug.stream = this.debug.$video.srcObject;\n              this.debug.$video.play();\n              this.emit('gotUserMedia', this.debug.stream);\n              callback && callback();\n              this.debug.isGettingStream = false;\n            }\n          } // If a media stream is getting gotten then run the callback once the media stream is ready\n\n        } else if (!this.debug.stream && this.debug.isGettingStream) {\n          callback && this.on('gotUserMedia', callback); // If everything is loaded then just call the callback\n        } else {\n          this.debug.$video.play();\n          this.emit('gotUserMedia', this.debug.stream);\n          callback && callback();\n        }\n      }\n      /**\r\n       * Loads all the core plugins (see #6)\r\n       */\n\n    }, {\n      key: \"loadCorePlugins\",\n      value: function loadCorePlugins() {\n        var _this42 = this;\n\n        Object.keys(corePlugins).forEach(function (name) {\n          _this42.use(name, corePlugins[name]);\n        });\n      }\n      /* //////////////////////// #7 DEBUGGER ////////////////////////\r\n      \r\n                \r\n           \r\n                   \r\n                     \r\n        \r\n                \r\n                                                                         \r\n        /////////////////////////////////////////////////////////////*/\n\n      /**\r\n       * Sets up the video and canvas elements\r\n       */\n\n    }, {\n      key: \"setupDebugger\",\n      value: function setupDebugger() {\n        var _this43 = this;\n\n        this.debug = {}; // debugger wrap\n\n        if (!this.config.setup.wrap.$el) {\n          var $wrap = document.createElement('DIV');\n          $wrap.classList.add('handsfree-debugger');\n          this.config.setup.wrap.$el = $wrap;\n        }\n\n        this.debug.$wrap = this.config.setup.wrap.$el; // Create video element\n\n        if (!this.config.setup.video.$el) {\n          var $video = document.createElement('VIDEO');\n          $video.setAttribute('playsinline', true);\n          $video.classList.add('handsfree-video');\n          $video.setAttribute('id', \"handsfree-video-\".concat(this.id));\n          this.config.setup.video.$el = $video;\n          this.isUsingWebcam = true;\n          this.debug.$video = this.config.setup.video.$el;\n          this.debug.$wrap.appendChild(this.debug.$video); // Use an existing element and see if a source is set\n        } else {\n          this.debug.$video = this.config.setup.video.$el;\n          this.isUsingWebcam = false;\n        }\n\n        this.debug.$video.width = this.config.setup.video.width;\n        this.debug.$video.height = this.config.setup.video.height; // Context 2D canvases\n\n        this.debug.$canvas = {};\n        this.debug.context = {};\n        this.config.setup.canvas.video = {\n          width: this.debug.$video.width,\n          height: this.debug.$video.height\n        } // The video canvas is used to display the video\n        ;\n        ['video', 'weboji', 'facemesh', 'pose', 'hands', 'handpose'].forEach(function (model) {\n          _this43.debug.$canvas[model] = {};\n          _this43.debug.context[model] = {};\n          var $canvas = _this43.config.setup.canvas[model].$el;\n\n          if (!$canvas) {\n            $canvas = document.createElement('CANVAS');\n            _this43.config.setup.canvas[model].$el = $canvas;\n          } // Classes\n\n\n          $canvas.classList.add('handsfree-canvas', \"handsfree-canvas-\".concat(model), \"handsfree-hide-when-started-without-\".concat(model));\n          $canvas.setAttribute('id', \"handsfree-canvas-\".concat(model, \"-\").concat(_this43.id)); // Dimensions\n\n          _this43.debug.$canvas[model] = _this43.config.setup.canvas[model].$el;\n          _this43.debug.$canvas[model].width = _this43.config.setup.canvas[model].width;\n          _this43.debug.$canvas[model].height = _this43.config.setup.canvas[model].height;\n\n          _this43.debug.$wrap.appendChild(_this43.debug.$canvas[model]); // Context\n\n\n          if (['weboji', 'handpose'].includes(model)) {\n            _this43.debug.$canvas[model].classList.add('handsfree-canvas-webgl');\n          } else {\n            _this43.debug.context[model] = _this43.debug.$canvas[model].getContext('2d');\n          }\n        }); // Append everything to the body\n\n        this.config.setup.wrap.$parent.appendChild(this.debug.$wrap); // Add classes\n\n        if (this.config.showDebug) {\n          this.showDebugger();\n        } else {\n          this.hideDebugger();\n        }\n      }\n      /**\r\n       * Shows the debugger\r\n       */\n\n    }, {\n      key: \"showDebugger\",\n      value: function showDebugger() {\n        this.isDebugging = true;\n        document.body.classList.add('handsfree-show-debug');\n        document.body.classList.remove('handsfree-hide-debug');\n      }\n      /**\r\n       * Hides the debugger\r\n       */\n\n    }, {\n      key: \"hideDebugger\",\n      value: function hideDebugger() {\n        this.isDebugging = false;\n        document.body.classList.remove('handsfree-show-debug');\n        document.body.classList.add('handsfree-hide-debug');\n      }\n    }]);\n\n    return Handsfree;\n  }();\n\n  return Handsfree;\n});","map":null,"metadata":{},"sourceType":"script"}